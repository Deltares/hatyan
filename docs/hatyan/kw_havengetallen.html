<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hatyan.kw_havengetallen API documentation</title>
<meta name="description" content="Created on Fri Dec 16 14:12:54 2022 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hatyan.kw_havengetallen</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Dec 16 14:12:54 2022</p>
<p>@author: veenstra</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Dec 16 14:12:54 2022

@author: veenstra
&#34;&#34;&#34;
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import datetime as dt
from hatyan.astrog import astrog_culminations
from hatyan.timeseries import calc_HWLWnumbering, calc_HWLWtidalrange

def get_moonculm_idxHWLWno(tstart,tstop):
    data_pd_moonculm = astrog_culminations(tFirst=tstart,tLast=tstop) # in UTC, which is important since data_pd_HWLW[&#39;culm_hr&#39;]=range(12) hourvalues should be in UTC since that relates to the relation dateline/sun
    data_pd_moonculm[&#39;datetime&#39;] = data_pd_moonculm[&#39;datetime&#39;].dt.tz_convert(&#39;UTC&#39;) #convert to UTC (is already)
    data_pd_moonculm[&#39;datetime&#39;] = data_pd_moonculm[&#39;datetime&#39;].dt.tz_localize(None) #remove timezone
    data_pd_moonculm = data_pd_moonculm.set_index(&#39;datetime&#39;,drop=False)
    data_pd_moonculm[&#39;values&#39;] = data_pd_moonculm[&#39;type&#39;] #dummy values for TA in hatyan.calc_HWLWnumbering()
    data_pd_moonculm[&#39;HWLWcode&#39;] = 1 #all HW values since one every ~12h25m
    data_pd_moonculm = calc_HWLWnumbering(data_pd_moonculm,doHWLWcheck=False) #TODO: currently w.r.t. cadzd, is that an issue? With DELFZL the matched culmination is incorrect (since far away), but that might not be a big issue
    moonculm_idxHWLWno = data_pd_moonculm.set_index(&#39;HWLWno&#39;)
    return moonculm_idxHWLWno


def calc_HWLW_moonculm_combi(data_pd_HWLW_12,culm_addtime=None):
    moonculm_idxHWLWno = get_moonculm_idxHWLWno(tstart=data_pd_HWLW_12.index.min()-dt.timedelta(days=3),tstop=data_pd_HWLW_12.index.max())
    moonculm_idxHWLWno.index = moonculm_idxHWLWno.index + 4 #correlate HWLW to moonculmination 2 days before. TODO: check this offset in relation to culm_addtime.

    data_pd_HWLW_idxHWLWno = calc_HWLWnumbering(data_pd_HWLW_12)
    data_pd_HWLW_idxHWLWno[&#39;times&#39;] = data_pd_HWLW_idxHWLWno.index
    data_pd_HWLW_idxHWLWno = data_pd_HWLW_idxHWLWno.set_index(&#39;HWLWno&#39;,drop=False)
    
    HW_bool = data_pd_HWLW_idxHWLWno[&#39;HWLWcode&#39;]==1
    data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;getijperiod&#39;] = data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;times&#39;].iloc[1:].values - data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;times&#39;].iloc[:-1] #this works properly since index is HWLW
    data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;duurdaling&#39;] = data_pd_HWLW_idxHWLWno.loc[~HW_bool,&#39;times&#39;] - data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;times&#39;]
    data_pd_HWLW_idxHWLWno[&#39;culm_time&#39;] = moonculm_idxHWLWno[&#39;datetime&#39;] #couple HWLW to moonculminations two days earlier (this works since index is HWLWno)
    data_pd_HWLW_idxHWLWno[&#39;culm_hr&#39;] = (data_pd_HWLW_idxHWLWno[&#39;culm_time&#39;].round(&#39;h&#39;).dt.hour)%12
    data_pd_HWLW_idxHWLWno[&#39;HWLW_delay&#39;] = data_pd_HWLW_idxHWLWno[&#39;times&#39;] - data_pd_HWLW_idxHWLWno[&#39;culm_time&#39;]
    if culm_addtime is not None:
        data_pd_HWLW_idxHWLWno[&#39;HWLW_delay&#39;] -= culm_addtime
    data_pd_HWLW = data_pd_HWLW_idxHWLWno.set_index(&#39;times&#39;)
    return data_pd_HWLW


def calc_HWLW_culmhr_summary(data_pd_HWLW):
    print(&#39;calculate medians per hour group for LW and HW (instead of 1991 method: average of subgroups with removal of outliers)&#39;)
    data_pd_HW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==1]
    data_pd_LW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==2]
    
    HWLW_culmhr_summary = pd.DataFrame()
    HWLW_culmhr_summary[&#39;HW_values_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;values&#39;].median()
    HWLW_culmhr_summary[&#39;HW_delay_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;HWLW_delay&#39;].median().round(&#39;S&#39;)
    HWLW_culmhr_summary[&#39;LW_values_median&#39;] = data_pd_LW.groupby(data_pd_LW[&#39;culm_hr&#39;])[&#39;values&#39;].median()
    HWLW_culmhr_summary[&#39;LW_delay_median&#39;] = data_pd_LW.groupby(data_pd_LW[&#39;culm_hr&#39;])[&#39;HWLW_delay&#39;].median().round(&#39;S&#39;)
    HWLW_culmhr_summary[&#39;tijverschil&#39;] = HWLW_culmhr_summary[&#39;HW_values_median&#39;] - HWLW_culmhr_summary[&#39;LW_values_median&#39;]
    HWLW_culmhr_summary[&#39;getijperiod_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;getijperiod&#39;].median().round(&#39;S&#39;)
    HWLW_culmhr_summary[&#39;duurdaling_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;duurdaling&#39;].median().round(&#39;S&#39;)
    
    HWLW_culmhr_summary.loc[&#39;mean&#39;,:] = HWLW_culmhr_summary.mean() #add mean row to dataframe (not convenient to add immediately due to plotting with index 0-11)
    for colname in HWLW_culmhr_summary.columns: #round timedelta to make outputformat nicer
        if HWLW_culmhr_summary[colname].dtype == &#39;timedelta64[ns]&#39;:
            HWLW_culmhr_summary[colname] = HWLW_culmhr_summary[colname].round(&#39;S&#39;)

    return HWLW_culmhr_summary


def calc_HWLW_culmhr_summary_tidalcoeff(data_pd_HWLW_12):
    #TODO: use tidal coefficient instead?: The tidal coefficient is the size of the tide in relation to its mean. It usually varies between 20 and 120. The higher the tidal coefficient, the larger the tidal range – i.e. the difference in water height between high and low tide. This means that the sea level rises and falls back a long way. The mean value is 70. We talk of strong tides – called spring tides – from coefficient 95.  Conversely, weak tides are called neap tides. https://escales.ponant.com/en/high-low-tide/ en https://www.manche-toerisme.com/springtij
    #for HOEKVHLD, sp=0 is approx tc=1.2, np=6 is approx tc=0.8, av=mean is approx tc=1.0 (for HW, for LW it is different)
    data_pd_HWLW = data_pd_HWLW_12.copy()
    data_pd_HWLW = calc_HWLWtidalrange(data_pd_HWLW)
    data_pd_HWLW[&#39;tidalcoeff&#39;] = data_pd_HWLW[&#39;tidalrange&#39;]/data_pd_HWLW[&#39;tidalrange&#39;].mean()
    data_pd_HWLW[&#39;tidalcoeff_round&#39;] = data_pd_HWLW[&#39;tidalcoeff&#39;].round(1)
    TR_groupby_median = data_pd_HWLW.groupby(&#39;tidalcoeff_round&#39;)[&#39;tidalrange&#39;].median()
    HW_groupby_median = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==1].groupby(&#39;tidalcoeff_round&#39;)[&#39;values&#39;].median()
    LW_groupby_median = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==2].groupby(&#39;tidalcoeff_round&#39;)[&#39;values&#39;].median()
    
    HWLW_culmhr_summary = pd.DataFrame()
    HWLW_culmhr_summary[&#39;HW_values_median&#39;] = HW_groupby_median
    HWLW_culmhr_summary[&#39;LW_values_median&#39;] = LW_groupby_median
    HWLW_culmhr_summary[&#39;tidalrange_median&#39;] = TR_groupby_median
    HWLW_culmhr_summary = HWLW_culmhr_summary.loc[[0.8,1.0,1.2]] #select neap/mean/springtide
    HWLW_culmhr_summary.index = [&#39;neap&#39;,&#39;mean&#39;,&#39;spring&#39;]
    
    return HWLW_culmhr_summary


def plot_HWLW_pertimeclass(data_pd_HWLW, HWLW_culmhr_summary):
    
    HWLW_culmhr_summary = HWLW_culmhr_summary.loc[:11].copy() #remove mean column
    
    fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2,figsize=(18,8), sharex=True)
    data_pd_HW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==1]
    data_pd_LW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==2]
    ax1.set_title(&#39;HW values&#39;)
    ax1.plot(data_pd_HW[&#39;culm_hr&#39;],data_pd_HW[&#39;values&#39;],&#39;.&#39;)
    ax1.plot(HWLW_culmhr_summary[&#39;HW_values_median&#39;],&#39;.-&#39;)
    ax2.set_title(&#39;LW values&#39;)
    ax2.plot(data_pd_LW[&#39;culm_hr&#39;],data_pd_LW[&#39;values&#39;],&#39;.&#39;)
    ax2.plot(HWLW_culmhr_summary[&#39;LW_values_median&#39;],&#39;.-&#39;)
    ax3.set_title(&#39;HW time delays&#39;)
    ax3.plot(data_pd_HW[&#39;culm_hr&#39;],data_pd_HW[&#39;HWLW_delay&#39;].dt.total_seconds()/3600,&#39;.&#39;)
    ax3.plot(HWLW_culmhr_summary[&#39;HW_delay_median&#39;].dt.total_seconds()/3600,&#39;.-&#39;)
    ax4.set_title(&#39;LW time delays&#39;)
    ax4.plot(data_pd_LW[&#39;culm_hr&#39;],data_pd_LW[&#39;HWLW_delay&#39;].dt.total_seconds()/3600,&#39;.&#39;)
    ax4.plot(HWLW_culmhr_summary[&#39;LW_delay_median&#39;].dt.total_seconds()/3600,&#39;.-&#39;)
    ax4.set_xlim([0-0.5,12-0.5])
    fig.tight_layout()
    axs = np.array(((ax1,ax2),(ax3,ax4)))
    
    return fig, axs


def plot_aardappelgrafiek(HWLW_culmhr_summary):
    
    HWLW_culmhr_summary = HWLW_culmhr_summary.loc[:11].copy() #remove mean column
    
    def timeTicks(x, pos):
        d = dt.timedelta(hours=np.abs(x))
        if np.sign(x)&gt;0:
            d_str = str(d)
        else:
            d_str = &#39;-&#39;+str(d)
        return d_str
    
    fig, (ax1,ax2) = plt.subplots(1,2,figsize=(7.5,4), sharex=False)
    ax1.set_title(&#39;HW&#39;)
    ax1.set_xlabel(&#39;maansverloop in uu:mm:ss&#39; )
    ax1.set_ylabel(&#39;waterstand in m t.o.v. NAP&#39;)
    ax1.plot(HWLW_culmhr_summary[&#39;HW_delay_median&#39;].dt.total_seconds()/3600,HWLW_culmhr_summary[&#39;HW_values_median&#39;],&#39;.-&#39;)
    ax1.xaxis.set_major_formatter(timeTicks)
    ax1.grid()
    ax2.set_title(&#39;LW&#39;)
    ax2.set_xlabel(&#39;maansverloop in uu:mm:ss&#39; )
    ax2.set_ylabel(&#39;waterstand in m t.o.v. NAP&#39;)
    ax2.plot(HWLW_culmhr_summary[&#39;LW_delay_median&#39;].dt.total_seconds()/3600,HWLW_culmhr_summary[&#39;LW_values_median&#39;],&#39;.-&#39;)
    ax2.xaxis.set_major_formatter(timeTicks)
    ax2.grid()
    for iH,row in HWLW_culmhr_summary.iterrows():
        ax1.text(row[&#39;HW_delay_median&#39;].total_seconds()/3600,row[&#39;HW_values_median&#39;], str(int(iH)))
        ax2.text(row[&#39;LW_delay_median&#39;].total_seconds()/3600,row[&#39;LW_values_median&#39;], str(int(iH)))
    #set equal ylims
    ax1_xlimmean = np.mean(ax1.get_xlim())
    ax2_xlimmean = np.mean(ax2.get_xlim())
    ax1_ylimmean = np.mean(ax1.get_ylim())
    ax2_ylimmean = np.mean(ax2.get_ylim())
    xlimrange = 2
    ylimrange = 1
    ax1.set_xlim([ax1_xlimmean-xlimrange/2,ax1_xlimmean+xlimrange/2])
    ax2.set_xlim([ax2_xlimmean-xlimrange/2,ax2_xlimmean+xlimrange/2])
    ax1.set_ylim([ax1_ylimmean-ylimrange/2,ax1_ylimmean+ylimrange/2])
    ax2.set_ylim([ax2_ylimmean-ylimrange/2,ax2_ylimmean+ylimrange/2])
    #plot gemtij dotted lines
    ax1.plot(ax1.get_xlim(),[HWLW_culmhr_summary[&#39;HW_values_median&#39;].mean(),HWLW_culmhr_summary[&#39;HW_values_median&#39;].mean()],&#39;k--&#39;)
    ax1.plot([HWLW_culmhr_summary[&#39;HW_delay_median&#39;].mean().total_seconds()/3600,HWLW_culmhr_summary[&#39;HW_delay_median&#39;].mean().total_seconds()/3600],ax1.get_ylim(),&#39;k--&#39;)
    ax2.plot(ax2.get_xlim(),[HWLW_culmhr_summary[&#39;LW_values_median&#39;].mean(),HWLW_culmhr_summary[&#39;LW_values_median&#39;].mean()],&#39;k--&#39;)
    ax2.plot([HWLW_culmhr_summary[&#39;LW_delay_median&#39;].mean().total_seconds()/3600,HWLW_culmhr_summary[&#39;LW_delay_median&#39;].mean().total_seconds()/3600],ax2.get_ylim(),&#39;k--&#39;)
    fig.tight_layout()
    
    axs = (ax1,ax2)
    return fig, axs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hatyan.kw_havengetallen.get_moonculm_idxHWLWno"><code class="name flex">
<span>def <span class="ident">get_moonculm_idxHWLWno</span></span>(<span>tstart, tstop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_moonculm_idxHWLWno(tstart,tstop):
    data_pd_moonculm = astrog_culminations(tFirst=tstart,tLast=tstop) # in UTC, which is important since data_pd_HWLW[&#39;culm_hr&#39;]=range(12) hourvalues should be in UTC since that relates to the relation dateline/sun
    data_pd_moonculm[&#39;datetime&#39;] = data_pd_moonculm[&#39;datetime&#39;].dt.tz_convert(&#39;UTC&#39;) #convert to UTC (is already)
    data_pd_moonculm[&#39;datetime&#39;] = data_pd_moonculm[&#39;datetime&#39;].dt.tz_localize(None) #remove timezone
    data_pd_moonculm = data_pd_moonculm.set_index(&#39;datetime&#39;,drop=False)
    data_pd_moonculm[&#39;values&#39;] = data_pd_moonculm[&#39;type&#39;] #dummy values for TA in hatyan.calc_HWLWnumbering()
    data_pd_moonculm[&#39;HWLWcode&#39;] = 1 #all HW values since one every ~12h25m
    data_pd_moonculm = calc_HWLWnumbering(data_pd_moonculm,doHWLWcheck=False) #TODO: currently w.r.t. cadzd, is that an issue? With DELFZL the matched culmination is incorrect (since far away), but that might not be a big issue
    moonculm_idxHWLWno = data_pd_moonculm.set_index(&#39;HWLWno&#39;)
    return moonculm_idxHWLWno</code></pre>
</details>
</dd>
<dt id="hatyan.kw_havengetallen.calc_HWLW_moonculm_combi"><code class="name flex">
<span>def <span class="ident">calc_HWLW_moonculm_combi</span></span>(<span>data_pd_HWLW_12, culm_addtime=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_HWLW_moonculm_combi(data_pd_HWLW_12,culm_addtime=None):
    moonculm_idxHWLWno = get_moonculm_idxHWLWno(tstart=data_pd_HWLW_12.index.min()-dt.timedelta(days=3),tstop=data_pd_HWLW_12.index.max())
    moonculm_idxHWLWno.index = moonculm_idxHWLWno.index + 4 #correlate HWLW to moonculmination 2 days before. TODO: check this offset in relation to culm_addtime.

    data_pd_HWLW_idxHWLWno = calc_HWLWnumbering(data_pd_HWLW_12)
    data_pd_HWLW_idxHWLWno[&#39;times&#39;] = data_pd_HWLW_idxHWLWno.index
    data_pd_HWLW_idxHWLWno = data_pd_HWLW_idxHWLWno.set_index(&#39;HWLWno&#39;,drop=False)
    
    HW_bool = data_pd_HWLW_idxHWLWno[&#39;HWLWcode&#39;]==1
    data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;getijperiod&#39;] = data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;times&#39;].iloc[1:].values - data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;times&#39;].iloc[:-1] #this works properly since index is HWLW
    data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;duurdaling&#39;] = data_pd_HWLW_idxHWLWno.loc[~HW_bool,&#39;times&#39;] - data_pd_HWLW_idxHWLWno.loc[HW_bool,&#39;times&#39;]
    data_pd_HWLW_idxHWLWno[&#39;culm_time&#39;] = moonculm_idxHWLWno[&#39;datetime&#39;] #couple HWLW to moonculminations two days earlier (this works since index is HWLWno)
    data_pd_HWLW_idxHWLWno[&#39;culm_hr&#39;] = (data_pd_HWLW_idxHWLWno[&#39;culm_time&#39;].round(&#39;h&#39;).dt.hour)%12
    data_pd_HWLW_idxHWLWno[&#39;HWLW_delay&#39;] = data_pd_HWLW_idxHWLWno[&#39;times&#39;] - data_pd_HWLW_idxHWLWno[&#39;culm_time&#39;]
    if culm_addtime is not None:
        data_pd_HWLW_idxHWLWno[&#39;HWLW_delay&#39;] -= culm_addtime
    data_pd_HWLW = data_pd_HWLW_idxHWLWno.set_index(&#39;times&#39;)
    return data_pd_HWLW</code></pre>
</details>
</dd>
<dt id="hatyan.kw_havengetallen.calc_HWLW_culmhr_summary"><code class="name flex">
<span>def <span class="ident">calc_HWLW_culmhr_summary</span></span>(<span>data_pd_HWLW)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_HWLW_culmhr_summary(data_pd_HWLW):
    print(&#39;calculate medians per hour group for LW and HW (instead of 1991 method: average of subgroups with removal of outliers)&#39;)
    data_pd_HW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==1]
    data_pd_LW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==2]
    
    HWLW_culmhr_summary = pd.DataFrame()
    HWLW_culmhr_summary[&#39;HW_values_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;values&#39;].median()
    HWLW_culmhr_summary[&#39;HW_delay_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;HWLW_delay&#39;].median().round(&#39;S&#39;)
    HWLW_culmhr_summary[&#39;LW_values_median&#39;] = data_pd_LW.groupby(data_pd_LW[&#39;culm_hr&#39;])[&#39;values&#39;].median()
    HWLW_culmhr_summary[&#39;LW_delay_median&#39;] = data_pd_LW.groupby(data_pd_LW[&#39;culm_hr&#39;])[&#39;HWLW_delay&#39;].median().round(&#39;S&#39;)
    HWLW_culmhr_summary[&#39;tijverschil&#39;] = HWLW_culmhr_summary[&#39;HW_values_median&#39;] - HWLW_culmhr_summary[&#39;LW_values_median&#39;]
    HWLW_culmhr_summary[&#39;getijperiod_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;getijperiod&#39;].median().round(&#39;S&#39;)
    HWLW_culmhr_summary[&#39;duurdaling_median&#39;] = data_pd_HW.groupby(data_pd_HW[&#39;culm_hr&#39;])[&#39;duurdaling&#39;].median().round(&#39;S&#39;)
    
    HWLW_culmhr_summary.loc[&#39;mean&#39;,:] = HWLW_culmhr_summary.mean() #add mean row to dataframe (not convenient to add immediately due to plotting with index 0-11)
    for colname in HWLW_culmhr_summary.columns: #round timedelta to make outputformat nicer
        if HWLW_culmhr_summary[colname].dtype == &#39;timedelta64[ns]&#39;:
            HWLW_culmhr_summary[colname] = HWLW_culmhr_summary[colname].round(&#39;S&#39;)

    return HWLW_culmhr_summary</code></pre>
</details>
</dd>
<dt id="hatyan.kw_havengetallen.calc_HWLW_culmhr_summary_tidalcoeff"><code class="name flex">
<span>def <span class="ident">calc_HWLW_culmhr_summary_tidalcoeff</span></span>(<span>data_pd_HWLW_12)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_HWLW_culmhr_summary_tidalcoeff(data_pd_HWLW_12):
    #TODO: use tidal coefficient instead?: The tidal coefficient is the size of the tide in relation to its mean. It usually varies between 20 and 120. The higher the tidal coefficient, the larger the tidal range – i.e. the difference in water height between high and low tide. This means that the sea level rises and falls back a long way. The mean value is 70. We talk of strong tides – called spring tides – from coefficient 95.  Conversely, weak tides are called neap tides. https://escales.ponant.com/en/high-low-tide/ en https://www.manche-toerisme.com/springtij
    #for HOEKVHLD, sp=0 is approx tc=1.2, np=6 is approx tc=0.8, av=mean is approx tc=1.0 (for HW, for LW it is different)
    data_pd_HWLW = data_pd_HWLW_12.copy()
    data_pd_HWLW = calc_HWLWtidalrange(data_pd_HWLW)
    data_pd_HWLW[&#39;tidalcoeff&#39;] = data_pd_HWLW[&#39;tidalrange&#39;]/data_pd_HWLW[&#39;tidalrange&#39;].mean()
    data_pd_HWLW[&#39;tidalcoeff_round&#39;] = data_pd_HWLW[&#39;tidalcoeff&#39;].round(1)
    TR_groupby_median = data_pd_HWLW.groupby(&#39;tidalcoeff_round&#39;)[&#39;tidalrange&#39;].median()
    HW_groupby_median = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==1].groupby(&#39;tidalcoeff_round&#39;)[&#39;values&#39;].median()
    LW_groupby_median = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==2].groupby(&#39;tidalcoeff_round&#39;)[&#39;values&#39;].median()
    
    HWLW_culmhr_summary = pd.DataFrame()
    HWLW_culmhr_summary[&#39;HW_values_median&#39;] = HW_groupby_median
    HWLW_culmhr_summary[&#39;LW_values_median&#39;] = LW_groupby_median
    HWLW_culmhr_summary[&#39;tidalrange_median&#39;] = TR_groupby_median
    HWLW_culmhr_summary = HWLW_culmhr_summary.loc[[0.8,1.0,1.2]] #select neap/mean/springtide
    HWLW_culmhr_summary.index = [&#39;neap&#39;,&#39;mean&#39;,&#39;spring&#39;]
    
    return HWLW_culmhr_summary</code></pre>
</details>
</dd>
<dt id="hatyan.kw_havengetallen.plot_HWLW_pertimeclass"><code class="name flex">
<span>def <span class="ident">plot_HWLW_pertimeclass</span></span>(<span>data_pd_HWLW, HWLW_culmhr_summary)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_HWLW_pertimeclass(data_pd_HWLW, HWLW_culmhr_summary):
    
    HWLW_culmhr_summary = HWLW_culmhr_summary.loc[:11].copy() #remove mean column
    
    fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2,figsize=(18,8), sharex=True)
    data_pd_HW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==1]
    data_pd_LW = data_pd_HWLW.loc[data_pd_HWLW[&#39;HWLWcode&#39;]==2]
    ax1.set_title(&#39;HW values&#39;)
    ax1.plot(data_pd_HW[&#39;culm_hr&#39;],data_pd_HW[&#39;values&#39;],&#39;.&#39;)
    ax1.plot(HWLW_culmhr_summary[&#39;HW_values_median&#39;],&#39;.-&#39;)
    ax2.set_title(&#39;LW values&#39;)
    ax2.plot(data_pd_LW[&#39;culm_hr&#39;],data_pd_LW[&#39;values&#39;],&#39;.&#39;)
    ax2.plot(HWLW_culmhr_summary[&#39;LW_values_median&#39;],&#39;.-&#39;)
    ax3.set_title(&#39;HW time delays&#39;)
    ax3.plot(data_pd_HW[&#39;culm_hr&#39;],data_pd_HW[&#39;HWLW_delay&#39;].dt.total_seconds()/3600,&#39;.&#39;)
    ax3.plot(HWLW_culmhr_summary[&#39;HW_delay_median&#39;].dt.total_seconds()/3600,&#39;.-&#39;)
    ax4.set_title(&#39;LW time delays&#39;)
    ax4.plot(data_pd_LW[&#39;culm_hr&#39;],data_pd_LW[&#39;HWLW_delay&#39;].dt.total_seconds()/3600,&#39;.&#39;)
    ax4.plot(HWLW_culmhr_summary[&#39;LW_delay_median&#39;].dt.total_seconds()/3600,&#39;.-&#39;)
    ax4.set_xlim([0-0.5,12-0.5])
    fig.tight_layout()
    axs = np.array(((ax1,ax2),(ax3,ax4)))
    
    return fig, axs</code></pre>
</details>
</dd>
<dt id="hatyan.kw_havengetallen.plot_aardappelgrafiek"><code class="name flex">
<span>def <span class="ident">plot_aardappelgrafiek</span></span>(<span>HWLW_culmhr_summary)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_aardappelgrafiek(HWLW_culmhr_summary):
    
    HWLW_culmhr_summary = HWLW_culmhr_summary.loc[:11].copy() #remove mean column
    
    def timeTicks(x, pos):
        d = dt.timedelta(hours=np.abs(x))
        if np.sign(x)&gt;0:
            d_str = str(d)
        else:
            d_str = &#39;-&#39;+str(d)
        return d_str
    
    fig, (ax1,ax2) = plt.subplots(1,2,figsize=(7.5,4), sharex=False)
    ax1.set_title(&#39;HW&#39;)
    ax1.set_xlabel(&#39;maansverloop in uu:mm:ss&#39; )
    ax1.set_ylabel(&#39;waterstand in m t.o.v. NAP&#39;)
    ax1.plot(HWLW_culmhr_summary[&#39;HW_delay_median&#39;].dt.total_seconds()/3600,HWLW_culmhr_summary[&#39;HW_values_median&#39;],&#39;.-&#39;)
    ax1.xaxis.set_major_formatter(timeTicks)
    ax1.grid()
    ax2.set_title(&#39;LW&#39;)
    ax2.set_xlabel(&#39;maansverloop in uu:mm:ss&#39; )
    ax2.set_ylabel(&#39;waterstand in m t.o.v. NAP&#39;)
    ax2.plot(HWLW_culmhr_summary[&#39;LW_delay_median&#39;].dt.total_seconds()/3600,HWLW_culmhr_summary[&#39;LW_values_median&#39;],&#39;.-&#39;)
    ax2.xaxis.set_major_formatter(timeTicks)
    ax2.grid()
    for iH,row in HWLW_culmhr_summary.iterrows():
        ax1.text(row[&#39;HW_delay_median&#39;].total_seconds()/3600,row[&#39;HW_values_median&#39;], str(int(iH)))
        ax2.text(row[&#39;LW_delay_median&#39;].total_seconds()/3600,row[&#39;LW_values_median&#39;], str(int(iH)))
    #set equal ylims
    ax1_xlimmean = np.mean(ax1.get_xlim())
    ax2_xlimmean = np.mean(ax2.get_xlim())
    ax1_ylimmean = np.mean(ax1.get_ylim())
    ax2_ylimmean = np.mean(ax2.get_ylim())
    xlimrange = 2
    ylimrange = 1
    ax1.set_xlim([ax1_xlimmean-xlimrange/2,ax1_xlimmean+xlimrange/2])
    ax2.set_xlim([ax2_xlimmean-xlimrange/2,ax2_xlimmean+xlimrange/2])
    ax1.set_ylim([ax1_ylimmean-ylimrange/2,ax1_ylimmean+ylimrange/2])
    ax2.set_ylim([ax2_ylimmean-ylimrange/2,ax2_ylimmean+ylimrange/2])
    #plot gemtij dotted lines
    ax1.plot(ax1.get_xlim(),[HWLW_culmhr_summary[&#39;HW_values_median&#39;].mean(),HWLW_culmhr_summary[&#39;HW_values_median&#39;].mean()],&#39;k--&#39;)
    ax1.plot([HWLW_culmhr_summary[&#39;HW_delay_median&#39;].mean().total_seconds()/3600,HWLW_culmhr_summary[&#39;HW_delay_median&#39;].mean().total_seconds()/3600],ax1.get_ylim(),&#39;k--&#39;)
    ax2.plot(ax2.get_xlim(),[HWLW_culmhr_summary[&#39;LW_values_median&#39;].mean(),HWLW_culmhr_summary[&#39;LW_values_median&#39;].mean()],&#39;k--&#39;)
    ax2.plot([HWLW_culmhr_summary[&#39;LW_delay_median&#39;].mean().total_seconds()/3600,HWLW_culmhr_summary[&#39;LW_delay_median&#39;].mean().total_seconds()/3600],ax2.get_ylim(),&#39;k--&#39;)
    fig.tight_layout()
    
    axs = (ax1,ax2)
    return fig, axs</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hatyan" href="index.html">hatyan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hatyan.kw_havengetallen.get_moonculm_idxHWLWno" href="#hatyan.kw_havengetallen.get_moonculm_idxHWLWno">get_moonculm_idxHWLWno</a></code></li>
<li><code><a title="hatyan.kw_havengetallen.calc_HWLW_moonculm_combi" href="#hatyan.kw_havengetallen.calc_HWLW_moonculm_combi">calc_HWLW_moonculm_combi</a></code></li>
<li><code><a title="hatyan.kw_havengetallen.calc_HWLW_culmhr_summary" href="#hatyan.kw_havengetallen.calc_HWLW_culmhr_summary">calc_HWLW_culmhr_summary</a></code></li>
<li><code><a title="hatyan.kw_havengetallen.calc_HWLW_culmhr_summary_tidalcoeff" href="#hatyan.kw_havengetallen.calc_HWLW_culmhr_summary_tidalcoeff">calc_HWLW_culmhr_summary_tidalcoeff</a></code></li>
<li><code><a title="hatyan.kw_havengetallen.plot_HWLW_pertimeclass" href="#hatyan.kw_havengetallen.plot_HWLW_pertimeclass">plot_HWLW_pertimeclass</a></code></li>
<li><code><a title="hatyan.kw_havengetallen.plot_aardappelgrafiek" href="#hatyan.kw_havengetallen.plot_aardappelgrafiek">plot_aardappelgrafiek</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>