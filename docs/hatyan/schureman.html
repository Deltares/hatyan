<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hatyan.schureman API documentation</title>
<meta name="description" content="schureman.py contains definitions with data for the schureman constituents â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hatyan.schureman</code></h1>
</header>
<section id="section-intro">
<p>schureman.py contains definitions with data for the schureman constituents.</p>
<p>hatyan is a Python program for tidal analysis and prediction, based on the FORTRAN version.
Copyright (C) 2019-2021 Rijkswaterstaat.
Maintained by Deltares, contact: Jelmer Veenstra (jelmer.veenstra@deltares.nl).
Source code available at: <a href="https://github.com/Deltares/hatyan">https://github.com/Deltares/hatyan</a></p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with this program.
If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># - * - coding: utf - 8 - * - 
&#34;&#34;&#34;
schureman.py contains definitions with data for the schureman constituents.

hatyan is a Python program for tidal analysis and prediction, based on the FORTRAN version. 
Copyright (C) 2019-2021 Rijkswaterstaat.  Maintained by Deltares, contact: Jelmer Veenstra (jelmer.veenstra@deltares.nl). 
Source code available at: https://github.com/Deltares/hatyan

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;

import os
import pandas as pd
import functools #to Memoize v0uf table (https://en.wikipedia.org/wiki/Memoization)
import numpy as np
import datetime as dt

file_path = os.path.realpath(__file__)


@functools.lru_cache()
def get_schureman_table():
    &#34;&#34;&#34;
    Calculate all schureman constituents

    Returns
    -------
    v0uf_all : TYPE
        DESCRIPTION.
    
    &#34;&#34;&#34;
    
    index_v0 = [&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;N&#39;,&#39;P1&#39;,&#39;EDN&#39;]
    index_u = [&#39;DKSI&#39;,&#39;DNU&#39;,&#39;DQ&#39;,&#39;DQU&#39;,&#39;DR&#39;,&#39;DUK1&#39;,&#39;DUK2&#39;]
    index_f = [&#39;DND73&#39;,&#39;DND74&#39;,&#39;DND75&#39;,&#39;DND76&#39;,&#39;DND77&#39;,&#39;DND78&#39;,&#39;DND79&#39;,&#39;DFM1&#39;,&#39;DFK1&#39;,&#39;DFL2&#39;,&#39;DFK2&#39;,&#39;DFM1C&#39;]
    #index_fstr =[&#39;f_eqs&#39;]

    file_schureman_harmonic = os.path.join(os.path.dirname(file_path),&#39;data&#39;,&#39;data_schureman_harmonic.csv&#39;)
    v0uf_baseT = pd.read_csv(file_schureman_harmonic,comment=&#39;#&#39;,skipinitialspace=True,index_col=&#39;component&#39;)
    v0uf_base = v0uf_baseT.T
    #v0uf_base.index = index_v0 + index_u + index_f + index_fstr
    
    file_schureman_shallowrelations = os.path.join(os.path.dirname(file_path),&#39;data&#39;,&#39;data_schureman_shallowrelations.csv&#39;)
    shallow_eqs_pd = pd.read_csv(file_schureman_shallowrelations,comment=&#39;#&#39;,skipinitialspace=True,index_col=0,names=[&#39;shallow_eq&#39;])
    shallow_eqs_pd[&#39;shallow_eq&#39;] = shallow_eqs_pd[&#39;shallow_eq&#39;].str.strip() #remove spaces after
    shallow_eqs_pd[&#39;shallow_const&#39;] = shallow_eqs_pd.index
    
    shallow_eqs_pd.index = &#39;comp_&#39;+shallow_eqs_pd.index.str.replace(&#39;(&#39;,&#39;&#39;,regex=False).str.replace(&#39;)&#39;,&#39;&#39;,regex=False)#brackets are temporarily removed in order to evaluate functions
    shallow_eqs_pd_str = &#39;\n&#39;.join(f&#39;{key} = {val}&#39; for key, val in shallow_eqs_pd[&#39;shallow_eq&#39;].iteritems()) 
    
    #calculate shallow water components and rename back to original component name
    v0uf_base_forv0u = v0uf_base.loc[index_v0+index_u,:].astype(int)
    v0uf_base_forv0u.eval(shallow_eqs_pd_str, inplace=True)
    v0uf_base_forf = v0uf_base.loc[index_f,:].astype(float)
    v0uf_base_forf.eval(shallow_eqs_pd_str.replace(&#39;-&#39;,&#39;+&#39;), inplace=True) #for f only multiplication is applied, never division
    v0uf_all = pd.concat([v0uf_base_forv0u,v0uf_base_forf])
    v0uf_all.rename(columns=shallow_eqs_pd[&#39;shallow_const&#39;],inplace=True)
    v0uf_allT = v0uf_all.T
    
    #from hatyan.hatyan_core import get_lunarSLSIHO_fromsolar # local import since otherwise cross-dependency
    #v0uf_allT_lunar, v0uf_allT_lunar_SLS, v0uf_allT_lunar_IHO = get_lunarSLSIHO_fromsolar(v0uf_all)
    
    return v0uf_allT


def get_schureman_freqs(const_list, dood_date=pd.DatetimeIndex([dt.datetime(1900,1,1)]), return_allraw=False):
    &#34;&#34;&#34;
    Returns the frequencies of the requested list of constituents. Source: beromg.f

    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    t_const_freq : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?
    
    doodson_pd = get_doodson_eqvals(dood_date=dood_date, mode=&#39;freq&#39;) #N is not used here
    multiply_variables = doodson_pd.loc[[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;],:]
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    v0uf_sel_freq = v0uf_sel[[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;]]
    
    DOMEGA_speed = np.dot(v0uf_sel_freq,multiply_variables)
    if return_allraw: #return array of speeds for each component/timestep
        return DOMEGA_speed
    
    #return dataframe of freq/angvelo/period/angfreq for all components and first timestep
    t_const_speed = DOMEGA_speed[:,0]
    t_const_freq = t_const_speed/(2*np.pi) #aantal rotaties per uur, freq
    np.seterr(divide=&#39;ignore&#39;) #suppress divide by 0 warning
    t_const_perds = 1/t_const_freq #period [hr]
    t_const_angfreqs = 360/t_const_perds #angfreq [deg/hr]
    freq_pd = pd.DataFrame({&#39;freq&#39;:t_const_freq, &#39;angvelo [rad/hr]&#39;:t_const_speed, &#39;period [hr]&#39;:t_const_perds, &#39;angfreq [deg/hr]&#39;:t_const_angfreqs}, index=const_list)
    return freq_pd


def get_schureman_v0(const_list, dood_date):
    &#34;&#34;&#34;
    Returns the v-values of the requested list of constituents for the requested date(s)
    
    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    v_0i_rad : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?

    doodson_pd = get_doodson_eqvals(dood_date=dood_date) #N is not used here
    multiply_variables = doodson_pd.loc[[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;],:]
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    DV0 = np.dot(v0uf_sel.loc[:,[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;]],multiply_variables) + np.deg2rad(v0uf_sel.loc[:,[&#39;EDN&#39;]]).values
    DV0_pd = pd.DataFrame(DV0,index=const_list)
    
    return DV0_pd


def get_schureman_constants(dood_date):
    &#34;&#34;&#34;
    get_schureman_constants

    Parameters
    ----------
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    DOMEGA : TYPE
        DESCRIPTION.
    DIKL : TYPE
        DESCRIPTION.
    DC1681 : TYPE
        DESCRIPTION.
    DC5023 : TYPE
        DESCRIPTION.
    DC0365 : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    #TODO: robust_timedelta_sec might also be necesary in other definitions, but is not there yet. Align? (also check if newer pandas version do not have this problem anymore)
    from hatyan.hatyan_core import robust_timedelta_sec # local import since otherwise cross-dependency
    
    #bercon.f: HET BEREKENEN VAN DE &#39;CONSTANTEN&#39; .0365, .1681 EN .5023, DIE GEBRUIKT WORDEN BIJ DE BEREKENING VAN DE U- EN F-FACTOREN VAN DE GETIJCOMPONENTEN K1 EN K2
    #327932: ratio of mass of sun to combined mass of earth and moon
    #81.53: ratio of mass of earth to mass of moon
    DAGC = 0.01657                            #A/C &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mean lunar parallax in respect to mean radius [rad]
    DAGC1 = 0.00004261                        #A/C1 &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mean solar parallax in respect to mean radius [rad]
    DE = 0.054900489                          #E &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, eccentricity of moons orbit
    DMGE = 1./81.53                           #M/E &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mass of moon /mass of earth
    DSGE = 82.53/81.53*327932                 #S/E &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mass of sun / mass of earth
    
    DU = DMGE*DAGC**3                         #U &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, basic factor
    DU1 = DSGE*DAGC1**3                       #U1 &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, solar coefficient
    DSACCE = DU1/DU                           #S&#39; &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, solar factor
    DOMEGA = np.deg2rad(23+27./60.+8.26/3600) #OMEGA &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, Obliquity of the Ecliptic, epoch 1 Jan 1900, 23.45229 graden [rad]
    DIKL = np.deg2rad(5+8./60.+43.3546/3600)  #i &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, Inclination of moons orbit to plane of ecliptic, epoch 1 Jan 1900 (?), 5.1453762 graden [rad]
    
    DC5023 = 0.5+0.75*DE*DE

    #time dependent
    dood_tstart_sec, fancy_pddt = robust_timedelta_sec(dood_date)    
    dood_Tj = (dood_tstart_sec/3600+12)/(24*36525)
    DE1 = 0.01675104-0.0000418*dood_Tj        #E1 &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, eccentricity of earths orbit, epoch 1 Jan 1900
    DCOFSI = (0.5+0.75*DE1**2)*DSACCE         #COEFFICIENT VAN DE SINUSTERMEN IN (217) EN (219) OP BLZ. 45 VAN SCHUREMAN

    DC0365 = DCOFSI*np.sin(DOMEGA)**2
    DC1681 = DCOFSI*np.sin(2*DOMEGA)
    
    return DOMEGA, DIKL, DC1681, DC5023, DC0365


def get_schureman_u(const_list, dood_date):
    &#34;&#34;&#34;
    Returns the u-values of the requested list of constituents for the requested date(s)

    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    u_i_rad_HAT : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?

    doodson_pd = get_doodson_eqvals(dood_date=dood_date)
    N_rad = doodson_pd.loc[&#39;N&#39;,:].values
    P_rad = doodson_pd.loc[&#39;P&#39;,:].values
    
    #list of dependencies for U (only P and N are used here)
    DOMEGA, DIKL, DC1681, DC5023, DC0365 = get_schureman_constants(dood_date)
    DHOMI = (DOMEGA-DIKL)*0.5
    DHOPI = (DOMEGA+DIKL)*0.5
    
    DTHN = np.tan(N_rad*0.5)
    DATC = np.arctan2(np.cos(DHOMI)*DTHN,np.cos(DHOPI))
    DATS = np.arctan2(np.sin(DHOMI)*DTHN,np.sin(DHOPI))
    DIH = np.arccos(np.cos(DIKL)*np.cos(DOMEGA)-np.sin(DIKL)*np.sin(DOMEGA)*np.cos(N_rad))
    DKSI = (N_rad-DATC-DATS)
    DNU = DATC-DATS
    DPMKSI = P_rad-DKSI
    DC2PMK = np.cos(DPMKSI+DPMKSI)
    DS2PMK = np.sin(DPMKSI+DPMKSI)
    DCIH = np.cos(DIH)
    DSIH = np.sin(DIH)
    DCHIH = np.cos(DIH*0.5)
    DCTHIH = 1./np.tan(DIH*0.5)
    DS2IH = np.sin(DIH+DIH)
    DQU = np.arctan2(DS2PMK,(3*DCIH/(DCHIH*DCHIH)+DC2PMK))
    DQ = np.arctan2((5*DCIH-1)*np.tan(DPMKSI),(7*DCIH+1))
    DNUACC = np.arctan2(DS2IH*np.sin(DNU),(DS2IH*np.cos(DNU)+DC1681/DC5023))
    DR = np.arctan2(DS2PMK,(DCTHIH*DCTHIH/6.-DC2PMK))
    D2NU2A = np.arctan2(DSIH**2*np.sin(2*DNU),(DSIH**2*np.cos(2*DNU)+DC0365/DC5023))
    DUK1   = -DNUACC 
    DUK2   = -D2NU2A
    multiply_variables = np.stack([DKSI, DNU, DQ, DQU, DR, DUK1, DUK2])
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    v0uf_sel_u = v0uf_sel[[&#39;DKSI&#39;,&#39;DNU&#39;, &#39;DQ&#39;, &#39;DQU&#39;, &#39;DR&#39;, &#39;DUK1&#39;, &#39;DUK2&#39;]]

    DU = np.dot(v0uf_sel_u.values,multiply_variables)
    DU = np.remainder(DU+np.pi, 2*np.pi) - np.pi

    #create dataframe
    DU_pd = pd.DataFrame(DU, index=const_list)
    
    return DU_pd


def get_schureman_f(const_list, dood_date, xfac):
    &#34;&#34;&#34;
    Returns the f-values of the requested list of constituents for the requested date(s)

    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    f_i_HAT : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?

    doodson_pd = get_doodson_eqvals(dood_date=dood_date)
    N_rad = doodson_pd.loc[&#39;N&#39;,:].values
    P_rad = doodson_pd.loc[&#39;P&#39;,:].values
    
    #list of dependencies F (only P and N are used here)
    DOMEGA, DIKL, DC1681, DC5023, DC0365 = get_schureman_constants(dood_date)
    DHOMI = (DOMEGA-DIKL)*0.5
    DHOPI = (DOMEGA+DIKL)*0.5
    DSOMEG = np.sin(DOMEGA)
    DSIKL = np.sin(DIKL)
    DTHN = np.tan(N_rad*0.5)
    DATC = np.arctan2(np.cos(DHOMI)*DTHN,np.cos(DHOPI))
    DATS = np.arctan2(np.sin(DHOMI)*DTHN,np.sin(DHOPI))
    DIH = np.arccos(np.cos(DIKL)*np.cos(DOMEGA)-DSIKL*DSOMEG*np.cos(N_rad))
    DKSI = (N_rad-DATC-DATS)%(2*np.pi)
    DNU = DATC-DATS#
    DCHOM = np.cos(DOMEGA*0.5) 
    DSHOM = np.sin(DOMEGA*0.5) 
    DSOM2 = DSOMEG*DSOMEG
    DCHOM2 = DCHOM*DCHOM 
    DSHOM2 = DSHOM*DSHOM 
    DCHIKL = np.cos(DIKL*0.5)  
    DCHIK4 = DCHIKL*DCHIKL*DCHIKL*DCHIKL
    D132S2 = 1-3./2.*DSIKL*DSIKL 
    DMOF65 = (2./3.-DSOM2)*D132S2  
    DMOF66 = DSOM2*DCHIK4
    DMOF67 = DSOMEG*DCHOM2*DCHIK4
    DMOF68 = np.sin(DOMEGA+DOMEGA)*D132S2
    DMOF69 = DSOMEG*DSHOM2*DCHIK4
    DMOF70 = DCHOM2*DCHOM2*DCHIK4
    DMOF71 = DSOM2*D132S2
    DSIH = np.sin(DIH)#
    DCHIH = np.cos(DIH*0.5)
    DSHIH = np.sin(DIH*0.5)
    DS2IH = np.sin(DIH+DIH)
    DTHIH2 = DSHIH**2/DCHIH**2
    DIGHI2 = np.cos(DIH)/DCHIH**2  
    DPMKSI = P_rad-DKSI
    DC2PMK = np.cos(DPMKSI+DPMKSI)
    DQA = 1./np.sqrt(0.25+1.5*DIGHI2*DC2PMK+2.25*DIGHI2*DIGHI2)
    DRA = 1./np.sqrt(1-12*DTHIH2*DC2PMK+36*DTHIH2*DTHIH2)
    
    #actual values used in the component list below (12 uniques)
    DND73 = (2./3.-DSIH**2)/DMOF65
    DND74 = DSIH**2/DMOF66 
    DND75 = DSIH*DCHIH**2/DMOF67 #DFQ1/DFO1
    DND76 = DS2IH/DMOF68 #DFJ1
    DND77 = DSIH*DSHIH**2/DMOF69 
    DND78 = DCHIH**2*DCHIH**2/DMOF70 #DFN2/DFNU2/DFM2/DFLAB2
    DND79 = DSIH**2/DMOF71 
    DFM1 = DND75/DQA #DFO1/DQA
    DFK1 = np.sqrt(DC5023*DC5023*DS2IH*DS2IH+2*DC5023*DC1681*DS2IH*np.cos(DNU)+DC1681*DC1681)/(DC5023*DMOF68+DC1681) 
    DFL2 = DND78/DRA #DFM2/DRA
    DFK2 = np.sqrt(DC5023*DC5023*DSIH**2*DSIH**2+2*DC5023*DC0365*DSIH**2*np.cos(DNU+DNU)+DC0365*DC0365)/(DC5023*DMOF71+DC0365)
    DFM1C = (1-10*DSHIH**2+15*DSHIH**2*DSHIH**2)*DCHIH**2/((1-10*DSHOM2+15*DSHOM2*DSHOM2)*DCHOM2)
    
    multiply_variables = np.stack([DND73,DND74,DND75,DND76,DND77,DND78,DND79,DFM1,DFK1,DFL2,DFK2,DFM1C])
    sel_cols = [&#39;DND73&#39;,&#39;DND74&#39;,&#39;DND75&#39;,&#39;DND76&#39;,&#39;DND77&#39;,&#39;DND78&#39;,&#39;DND79&#39;,&#39;DFM1&#39;,&#39;DFK1&#39;,&#39;DFL2&#39;,&#39;DFK2&#39;,&#39;DFM1C&#39;]
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    f_i = np.ones(shape=(len(const_list), len(dood_date)))
    for variable, colname in zip(multiply_variables, sel_cols): #this loop is faster than array multiplications, since it only calculates the necessary factors (saves a lot of overhead)
        power = v0uf_sel[colname].values
        idnozero = power!=0
        f_i[idnozero,:] *= variable**power[idnozero][np.newaxis].T
    
    v0uf_M2 = v0uf_allT.loc[[&#39;M2&#39;]]
    f_i_M2 = np.ones(shape=(len([&#39;M2&#39;]), len(dood_date)))
    for variable, colname in zip(multiply_variables, sel_cols): 
        power = v0uf_M2[colname].values
        idnozero = power!=0
        f_i_M2[idnozero,:] *= variable**power[idnozero][np.newaxis].T
    
    #create dataframe
    f_i_pd = pd.DataFrame(f_i, index=const_list)
    f_i_M2_pd = pd.DataFrame(f_i_M2, index = [&#39;M2&#39;])
    
    if xfac: #if variable is not: None, False, 0, more?
        f_i_pd = correct_fwith_xfac(f_i_pd, f_i_M2_pd, xfac=xfac)
    
    return f_i_pd


def correct_fwith_xfac(f_i_pd, f_i_M2_pd, xfac):
    &#34;&#34;&#34;
    Correct f-values with xfactor, this definition is only ran when xfac=True.

    Parameters
    ----------
    f_i_pd : TYPE
        DESCRIPTION.
    f_i_M2_pd : TYPE
        DESCRIPTION.

    Returns
    -------
    f_i_pd : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    if isinstance(xfac,dict):
        print(&#39;xfac dictionary provided: %s&#39;%(xfac))
        xfac_values = xfac
    else: #use default xfactor values
        xfac_values = {&#39;MU2&#39;: 0.00, # 0 betekent knoopfactor uit, 1 is helemaal aan
                       &#39;N2&#39;:  0.00,
                       &#39;NU2&#39;: 0.80,
                       &#39;M2&#39;:  0.53,
                       &#39;2MN2&#39;:0.20,
                       &#39;S2&#39;: -0.82,
                       &#39;M4&#39;:  0.70,
                       &#39;MS4&#39;: 0.00,
                       &#39;M6&#39;:  0.75,
                       &#39;2MS6&#39;:0.20,
                       &#39;M8&#39;:  0.70,
                       &#39;3MS8&#39;:0.60}
    
    for xfac_const in xfac_values.keys():
        if not xfac_const in f_i_pd.index:
            continue
        if all(f_i_pd.loc[xfac_const] == 1): # HET IS EEN NIET-KNOOPAFHANKELIJKE COMPONENT (F=1) (like S2)
            f_i_pd.loc[[xfac_const]] = xfac_values[xfac_const]*(f_i_M2_pd.loc[[&#39;M2&#39;],:].values-1)+1 # # hvufea.f line 176. uit v0uf_M2 ipv v0uf_sel, want daar is M2 waarde nog niet gecorrigeerd met xfac (kan ook uit f_i_HAT komen maar daar zit M2 niet per definitie in)
        else: # HET IS EEN KNOOPAFHANKELIJKE COMPONENT (F#1)
            f_i_pd.loc[[xfac_const]] = xfac_values[xfac_const]*(f_i_pd.loc[[xfac_const],:]-1)+1 # uit document tom bogaard, en hvufea.f line 181. staat ook in hatyan gebruikershandleiding bij knoopfactoren (pag2-5)

    return f_i_pd</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hatyan.schureman.get_schureman_table"><code class="name flex">
<span>def <span class="ident">get_schureman_table</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate all schureman constituents</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>v0uf_all</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@functools.lru_cache()
def get_schureman_table():
    &#34;&#34;&#34;
    Calculate all schureman constituents

    Returns
    -------
    v0uf_all : TYPE
        DESCRIPTION.
    
    &#34;&#34;&#34;
    
    index_v0 = [&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;N&#39;,&#39;P1&#39;,&#39;EDN&#39;]
    index_u = [&#39;DKSI&#39;,&#39;DNU&#39;,&#39;DQ&#39;,&#39;DQU&#39;,&#39;DR&#39;,&#39;DUK1&#39;,&#39;DUK2&#39;]
    index_f = [&#39;DND73&#39;,&#39;DND74&#39;,&#39;DND75&#39;,&#39;DND76&#39;,&#39;DND77&#39;,&#39;DND78&#39;,&#39;DND79&#39;,&#39;DFM1&#39;,&#39;DFK1&#39;,&#39;DFL2&#39;,&#39;DFK2&#39;,&#39;DFM1C&#39;]
    #index_fstr =[&#39;f_eqs&#39;]

    file_schureman_harmonic = os.path.join(os.path.dirname(file_path),&#39;data&#39;,&#39;data_schureman_harmonic.csv&#39;)
    v0uf_baseT = pd.read_csv(file_schureman_harmonic,comment=&#39;#&#39;,skipinitialspace=True,index_col=&#39;component&#39;)
    v0uf_base = v0uf_baseT.T
    #v0uf_base.index = index_v0 + index_u + index_f + index_fstr
    
    file_schureman_shallowrelations = os.path.join(os.path.dirname(file_path),&#39;data&#39;,&#39;data_schureman_shallowrelations.csv&#39;)
    shallow_eqs_pd = pd.read_csv(file_schureman_shallowrelations,comment=&#39;#&#39;,skipinitialspace=True,index_col=0,names=[&#39;shallow_eq&#39;])
    shallow_eqs_pd[&#39;shallow_eq&#39;] = shallow_eqs_pd[&#39;shallow_eq&#39;].str.strip() #remove spaces after
    shallow_eqs_pd[&#39;shallow_const&#39;] = shallow_eqs_pd.index
    
    shallow_eqs_pd.index = &#39;comp_&#39;+shallow_eqs_pd.index.str.replace(&#39;(&#39;,&#39;&#39;,regex=False).str.replace(&#39;)&#39;,&#39;&#39;,regex=False)#brackets are temporarily removed in order to evaluate functions
    shallow_eqs_pd_str = &#39;\n&#39;.join(f&#39;{key} = {val}&#39; for key, val in shallow_eqs_pd[&#39;shallow_eq&#39;].iteritems()) 
    
    #calculate shallow water components and rename back to original component name
    v0uf_base_forv0u = v0uf_base.loc[index_v0+index_u,:].astype(int)
    v0uf_base_forv0u.eval(shallow_eqs_pd_str, inplace=True)
    v0uf_base_forf = v0uf_base.loc[index_f,:].astype(float)
    v0uf_base_forf.eval(shallow_eqs_pd_str.replace(&#39;-&#39;,&#39;+&#39;), inplace=True) #for f only multiplication is applied, never division
    v0uf_all = pd.concat([v0uf_base_forv0u,v0uf_base_forf])
    v0uf_all.rename(columns=shallow_eqs_pd[&#39;shallow_const&#39;],inplace=True)
    v0uf_allT = v0uf_all.T
    
    #from hatyan.hatyan_core import get_lunarSLSIHO_fromsolar # local import since otherwise cross-dependency
    #v0uf_allT_lunar, v0uf_allT_lunar_SLS, v0uf_allT_lunar_IHO = get_lunarSLSIHO_fromsolar(v0uf_all)
    
    return v0uf_allT</code></pre>
</details>
</dd>
<dt id="hatyan.schureman.get_schureman_freqs"><code class="name flex">
<span>def <span class="ident">get_schureman_freqs</span></span>(<span>const_list, dood_date=DatetimeIndex(['1900-01-01'], dtype='datetime64[ns]', freq=None), return_allraw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the frequencies of the requested list of constituents. Source: beromg.f</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>const_list</code></strong> :&ensp;<code>list</code> or <code>pandas.Series</code></dt>
<dd>contains the tidal constituent names.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t_const_freq</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schureman_freqs(const_list, dood_date=pd.DatetimeIndex([dt.datetime(1900,1,1)]), return_allraw=False):
    &#34;&#34;&#34;
    Returns the frequencies of the requested list of constituents. Source: beromg.f

    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    t_const_freq : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?
    
    doodson_pd = get_doodson_eqvals(dood_date=dood_date, mode=&#39;freq&#39;) #N is not used here
    multiply_variables = doodson_pd.loc[[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;],:]
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    v0uf_sel_freq = v0uf_sel[[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;]]
    
    DOMEGA_speed = np.dot(v0uf_sel_freq,multiply_variables)
    if return_allraw: #return array of speeds for each component/timestep
        return DOMEGA_speed
    
    #return dataframe of freq/angvelo/period/angfreq for all components and first timestep
    t_const_speed = DOMEGA_speed[:,0]
    t_const_freq = t_const_speed/(2*np.pi) #aantal rotaties per uur, freq
    np.seterr(divide=&#39;ignore&#39;) #suppress divide by 0 warning
    t_const_perds = 1/t_const_freq #period [hr]
    t_const_angfreqs = 360/t_const_perds #angfreq [deg/hr]
    freq_pd = pd.DataFrame({&#39;freq&#39;:t_const_freq, &#39;angvelo [rad/hr]&#39;:t_const_speed, &#39;period [hr]&#39;:t_const_perds, &#39;angfreq [deg/hr]&#39;:t_const_angfreqs}, index=const_list)
    return freq_pd</code></pre>
</details>
</dd>
<dt id="hatyan.schureman.get_schureman_v0"><code class="name flex">
<span>def <span class="ident">get_schureman_v0</span></span>(<span>const_list, dood_date)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the v-values of the requested list of constituents for the requested date(s)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>const_list</code></strong> :&ensp;<code>list</code> or <code>pandas.Series</code></dt>
<dd>contains the tidal constituent names.</dd>
<dt><strong><code>dood_date</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>v_0i_rad</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schureman_v0(const_list, dood_date):
    &#34;&#34;&#34;
    Returns the v-values of the requested list of constituents for the requested date(s)
    
    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    v_0i_rad : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?

    doodson_pd = get_doodson_eqvals(dood_date=dood_date) #N is not used here
    multiply_variables = doodson_pd.loc[[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;],:]
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    DV0 = np.dot(v0uf_sel.loc[:,[&#39;T&#39;,&#39;S&#39;,&#39;H&#39;,&#39;P&#39;,&#39;P1&#39;]],multiply_variables) + np.deg2rad(v0uf_sel.loc[:,[&#39;EDN&#39;]]).values
    DV0_pd = pd.DataFrame(DV0,index=const_list)
    
    return DV0_pd</code></pre>
</details>
</dd>
<dt id="hatyan.schureman.get_schureman_constants"><code class="name flex">
<span>def <span class="ident">get_schureman_constants</span></span>(<span>dood_date)</span>
</code></dt>
<dd>
<div class="desc"><p>get_schureman_constants</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dood_date</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>DOMEGA</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>DIKL</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>DC1681</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>DC5023</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>DC0365</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schureman_constants(dood_date):
    &#34;&#34;&#34;
    get_schureman_constants

    Parameters
    ----------
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    DOMEGA : TYPE
        DESCRIPTION.
    DIKL : TYPE
        DESCRIPTION.
    DC1681 : TYPE
        DESCRIPTION.
    DC5023 : TYPE
        DESCRIPTION.
    DC0365 : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    #TODO: robust_timedelta_sec might also be necesary in other definitions, but is not there yet. Align? (also check if newer pandas version do not have this problem anymore)
    from hatyan.hatyan_core import robust_timedelta_sec # local import since otherwise cross-dependency
    
    #bercon.f: HET BEREKENEN VAN DE &#39;CONSTANTEN&#39; .0365, .1681 EN .5023, DIE GEBRUIKT WORDEN BIJ DE BEREKENING VAN DE U- EN F-FACTOREN VAN DE GETIJCOMPONENTEN K1 EN K2
    #327932: ratio of mass of sun to combined mass of earth and moon
    #81.53: ratio of mass of earth to mass of moon
    DAGC = 0.01657                            #A/C &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mean lunar parallax in respect to mean radius [rad]
    DAGC1 = 0.00004261                        #A/C1 &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mean solar parallax in respect to mean radius [rad]
    DE = 0.054900489                          #E &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, eccentricity of moons orbit
    DMGE = 1./81.53                           #M/E &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mass of moon /mass of earth
    DSGE = 82.53/81.53*327932                 #S/E &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, mass of sun / mass of earth
    
    DU = DMGE*DAGC**3                         #U &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, basic factor
    DU1 = DSGE*DAGC1**3                       #U1 &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, solar coefficient
    DSACCE = DU1/DU                           #S&#39; &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, solar factor
    DOMEGA = np.deg2rad(23+27./60.+8.26/3600) #OMEGA &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, Obliquity of the Ecliptic, epoch 1 Jan 1900, 23.45229 graden [rad]
    DIKL = np.deg2rad(5+8./60.+43.3546/3600)  #i &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, Inclination of moons orbit to plane of ecliptic, epoch 1 Jan 1900 (?), 5.1453762 graden [rad]
    
    DC5023 = 0.5+0.75*DE*DE

    #time dependent
    dood_tstart_sec, fancy_pddt = robust_timedelta_sec(dood_date)    
    dood_Tj = (dood_tstart_sec/3600+12)/(24*36525)
    DE1 = 0.01675104-0.0000418*dood_Tj        #E1 &gt;&gt; ZIE BLZ. 162 VAN SCHUREMAN, eccentricity of earths orbit, epoch 1 Jan 1900
    DCOFSI = (0.5+0.75*DE1**2)*DSACCE         #COEFFICIENT VAN DE SINUSTERMEN IN (217) EN (219) OP BLZ. 45 VAN SCHUREMAN

    DC0365 = DCOFSI*np.sin(DOMEGA)**2
    DC1681 = DCOFSI*np.sin(2*DOMEGA)
    
    return DOMEGA, DIKL, DC1681, DC5023, DC0365</code></pre>
</details>
</dd>
<dt id="hatyan.schureman.get_schureman_u"><code class="name flex">
<span>def <span class="ident">get_schureman_u</span></span>(<span>const_list, dood_date)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the u-values of the requested list of constituents for the requested date(s)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>const_list</code></strong> :&ensp;<code>list</code> or <code>pandas.Series</code></dt>
<dd>contains the tidal constituent names.</dd>
<dt><strong><code>dood_date</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u_i_rad_HAT</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schureman_u(const_list, dood_date):
    &#34;&#34;&#34;
    Returns the u-values of the requested list of constituents for the requested date(s)

    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    u_i_rad_HAT : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?

    doodson_pd = get_doodson_eqvals(dood_date=dood_date)
    N_rad = doodson_pd.loc[&#39;N&#39;,:].values
    P_rad = doodson_pd.loc[&#39;P&#39;,:].values
    
    #list of dependencies for U (only P and N are used here)
    DOMEGA, DIKL, DC1681, DC5023, DC0365 = get_schureman_constants(dood_date)
    DHOMI = (DOMEGA-DIKL)*0.5
    DHOPI = (DOMEGA+DIKL)*0.5
    
    DTHN = np.tan(N_rad*0.5)
    DATC = np.arctan2(np.cos(DHOMI)*DTHN,np.cos(DHOPI))
    DATS = np.arctan2(np.sin(DHOMI)*DTHN,np.sin(DHOPI))
    DIH = np.arccos(np.cos(DIKL)*np.cos(DOMEGA)-np.sin(DIKL)*np.sin(DOMEGA)*np.cos(N_rad))
    DKSI = (N_rad-DATC-DATS)
    DNU = DATC-DATS
    DPMKSI = P_rad-DKSI
    DC2PMK = np.cos(DPMKSI+DPMKSI)
    DS2PMK = np.sin(DPMKSI+DPMKSI)
    DCIH = np.cos(DIH)
    DSIH = np.sin(DIH)
    DCHIH = np.cos(DIH*0.5)
    DCTHIH = 1./np.tan(DIH*0.5)
    DS2IH = np.sin(DIH+DIH)
    DQU = np.arctan2(DS2PMK,(3*DCIH/(DCHIH*DCHIH)+DC2PMK))
    DQ = np.arctan2((5*DCIH-1)*np.tan(DPMKSI),(7*DCIH+1))
    DNUACC = np.arctan2(DS2IH*np.sin(DNU),(DS2IH*np.cos(DNU)+DC1681/DC5023))
    DR = np.arctan2(DS2PMK,(DCTHIH*DCTHIH/6.-DC2PMK))
    D2NU2A = np.arctan2(DSIH**2*np.sin(2*DNU),(DSIH**2*np.cos(2*DNU)+DC0365/DC5023))
    DUK1   = -DNUACC 
    DUK2   = -D2NU2A
    multiply_variables = np.stack([DKSI, DNU, DQ, DQU, DR, DUK1, DUK2])
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    v0uf_sel_u = v0uf_sel[[&#39;DKSI&#39;,&#39;DNU&#39;, &#39;DQ&#39;, &#39;DQU&#39;, &#39;DR&#39;, &#39;DUK1&#39;, &#39;DUK2&#39;]]

    DU = np.dot(v0uf_sel_u.values,multiply_variables)
    DU = np.remainder(DU+np.pi, 2*np.pi) - np.pi

    #create dataframe
    DU_pd = pd.DataFrame(DU, index=const_list)
    
    return DU_pd</code></pre>
</details>
</dd>
<dt id="hatyan.schureman.get_schureman_f"><code class="name flex">
<span>def <span class="ident">get_schureman_f</span></span>(<span>const_list, dood_date, xfac)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the f-values of the requested list of constituents for the requested date(s)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>const_list</code></strong> :&ensp;<code>list</code> or <code>pandas.Series</code></dt>
<dd>contains the tidal constituent names.</dd>
<dt><strong><code>dood_date</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>f_i_HAT</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schureman_f(const_list, dood_date, xfac):
    &#34;&#34;&#34;
    Returns the f-values of the requested list of constituents for the requested date(s)

    Parameters
    ----------
    const_list : list or pandas.Series
        contains the tidal constituent names.
    dood_date : TYPE
        DESCRIPTION.

    Returns
    -------
    f_i_HAT : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from hatyan.hatyan_core import get_doodson_eqvals, check_requestedconsts # local import since otherwise cross-dependency
    
    check_requestedconsts(tuple(const_list),source=&#39;schureman&#39;) #TODO: move check to central location when part of hatyan_settings()?

    doodson_pd = get_doodson_eqvals(dood_date=dood_date)
    N_rad = doodson_pd.loc[&#39;N&#39;,:].values
    P_rad = doodson_pd.loc[&#39;P&#39;,:].values
    
    #list of dependencies F (only P and N are used here)
    DOMEGA, DIKL, DC1681, DC5023, DC0365 = get_schureman_constants(dood_date)
    DHOMI = (DOMEGA-DIKL)*0.5
    DHOPI = (DOMEGA+DIKL)*0.5
    DSOMEG = np.sin(DOMEGA)
    DSIKL = np.sin(DIKL)
    DTHN = np.tan(N_rad*0.5)
    DATC = np.arctan2(np.cos(DHOMI)*DTHN,np.cos(DHOPI))
    DATS = np.arctan2(np.sin(DHOMI)*DTHN,np.sin(DHOPI))
    DIH = np.arccos(np.cos(DIKL)*np.cos(DOMEGA)-DSIKL*DSOMEG*np.cos(N_rad))
    DKSI = (N_rad-DATC-DATS)%(2*np.pi)
    DNU = DATC-DATS#
    DCHOM = np.cos(DOMEGA*0.5) 
    DSHOM = np.sin(DOMEGA*0.5) 
    DSOM2 = DSOMEG*DSOMEG
    DCHOM2 = DCHOM*DCHOM 
    DSHOM2 = DSHOM*DSHOM 
    DCHIKL = np.cos(DIKL*0.5)  
    DCHIK4 = DCHIKL*DCHIKL*DCHIKL*DCHIKL
    D132S2 = 1-3./2.*DSIKL*DSIKL 
    DMOF65 = (2./3.-DSOM2)*D132S2  
    DMOF66 = DSOM2*DCHIK4
    DMOF67 = DSOMEG*DCHOM2*DCHIK4
    DMOF68 = np.sin(DOMEGA+DOMEGA)*D132S2
    DMOF69 = DSOMEG*DSHOM2*DCHIK4
    DMOF70 = DCHOM2*DCHOM2*DCHIK4
    DMOF71 = DSOM2*D132S2
    DSIH = np.sin(DIH)#
    DCHIH = np.cos(DIH*0.5)
    DSHIH = np.sin(DIH*0.5)
    DS2IH = np.sin(DIH+DIH)
    DTHIH2 = DSHIH**2/DCHIH**2
    DIGHI2 = np.cos(DIH)/DCHIH**2  
    DPMKSI = P_rad-DKSI
    DC2PMK = np.cos(DPMKSI+DPMKSI)
    DQA = 1./np.sqrt(0.25+1.5*DIGHI2*DC2PMK+2.25*DIGHI2*DIGHI2)
    DRA = 1./np.sqrt(1-12*DTHIH2*DC2PMK+36*DTHIH2*DTHIH2)
    
    #actual values used in the component list below (12 uniques)
    DND73 = (2./3.-DSIH**2)/DMOF65
    DND74 = DSIH**2/DMOF66 
    DND75 = DSIH*DCHIH**2/DMOF67 #DFQ1/DFO1
    DND76 = DS2IH/DMOF68 #DFJ1
    DND77 = DSIH*DSHIH**2/DMOF69 
    DND78 = DCHIH**2*DCHIH**2/DMOF70 #DFN2/DFNU2/DFM2/DFLAB2
    DND79 = DSIH**2/DMOF71 
    DFM1 = DND75/DQA #DFO1/DQA
    DFK1 = np.sqrt(DC5023*DC5023*DS2IH*DS2IH+2*DC5023*DC1681*DS2IH*np.cos(DNU)+DC1681*DC1681)/(DC5023*DMOF68+DC1681) 
    DFL2 = DND78/DRA #DFM2/DRA
    DFK2 = np.sqrt(DC5023*DC5023*DSIH**2*DSIH**2+2*DC5023*DC0365*DSIH**2*np.cos(DNU+DNU)+DC0365*DC0365)/(DC5023*DMOF71+DC0365)
    DFM1C = (1-10*DSHIH**2+15*DSHIH**2*DSHIH**2)*DCHIH**2/((1-10*DSHOM2+15*DSHOM2*DSHOM2)*DCHOM2)
    
    multiply_variables = np.stack([DND73,DND74,DND75,DND76,DND77,DND78,DND79,DFM1,DFK1,DFL2,DFK2,DFM1C])
    sel_cols = [&#39;DND73&#39;,&#39;DND74&#39;,&#39;DND75&#39;,&#39;DND76&#39;,&#39;DND77&#39;,&#39;DND78&#39;,&#39;DND79&#39;,&#39;DFM1&#39;,&#39;DFK1&#39;,&#39;DFL2&#39;,&#39;DFK2&#39;,&#39;DFM1C&#39;]
    
    v0uf_allT = get_schureman_table()
    v0uf_sel = v0uf_allT.loc[const_list]
    f_i = np.ones(shape=(len(const_list), len(dood_date)))
    for variable, colname in zip(multiply_variables, sel_cols): #this loop is faster than array multiplications, since it only calculates the necessary factors (saves a lot of overhead)
        power = v0uf_sel[colname].values
        idnozero = power!=0
        f_i[idnozero,:] *= variable**power[idnozero][np.newaxis].T
    
    v0uf_M2 = v0uf_allT.loc[[&#39;M2&#39;]]
    f_i_M2 = np.ones(shape=(len([&#39;M2&#39;]), len(dood_date)))
    for variable, colname in zip(multiply_variables, sel_cols): 
        power = v0uf_M2[colname].values
        idnozero = power!=0
        f_i_M2[idnozero,:] *= variable**power[idnozero][np.newaxis].T
    
    #create dataframe
    f_i_pd = pd.DataFrame(f_i, index=const_list)
    f_i_M2_pd = pd.DataFrame(f_i_M2, index = [&#39;M2&#39;])
    
    if xfac: #if variable is not: None, False, 0, more?
        f_i_pd = correct_fwith_xfac(f_i_pd, f_i_M2_pd, xfac=xfac)
    
    return f_i_pd</code></pre>
</details>
</dd>
<dt id="hatyan.schureman.correct_fwith_xfac"><code class="name flex">
<span>def <span class="ident">correct_fwith_xfac</span></span>(<span>f_i_pd, f_i_M2_pd, xfac)</span>
</code></dt>
<dd>
<div class="desc"><p>Correct f-values with xfactor, this definition is only ran when xfac=True.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f_i_pd</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>f_i_M2_pd</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>f_i_pd</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_fwith_xfac(f_i_pd, f_i_M2_pd, xfac):
    &#34;&#34;&#34;
    Correct f-values with xfactor, this definition is only ran when xfac=True.

    Parameters
    ----------
    f_i_pd : TYPE
        DESCRIPTION.
    f_i_M2_pd : TYPE
        DESCRIPTION.

    Returns
    -------
    f_i_pd : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    if isinstance(xfac,dict):
        print(&#39;xfac dictionary provided: %s&#39;%(xfac))
        xfac_values = xfac
    else: #use default xfactor values
        xfac_values = {&#39;MU2&#39;: 0.00, # 0 betekent knoopfactor uit, 1 is helemaal aan
                       &#39;N2&#39;:  0.00,
                       &#39;NU2&#39;: 0.80,
                       &#39;M2&#39;:  0.53,
                       &#39;2MN2&#39;:0.20,
                       &#39;S2&#39;: -0.82,
                       &#39;M4&#39;:  0.70,
                       &#39;MS4&#39;: 0.00,
                       &#39;M6&#39;:  0.75,
                       &#39;2MS6&#39;:0.20,
                       &#39;M8&#39;:  0.70,
                       &#39;3MS8&#39;:0.60}
    
    for xfac_const in xfac_values.keys():
        if not xfac_const in f_i_pd.index:
            continue
        if all(f_i_pd.loc[xfac_const] == 1): # HET IS EEN NIET-KNOOPAFHANKELIJKE COMPONENT (F=1) (like S2)
            f_i_pd.loc[[xfac_const]] = xfac_values[xfac_const]*(f_i_M2_pd.loc[[&#39;M2&#39;],:].values-1)+1 # # hvufea.f line 176. uit v0uf_M2 ipv v0uf_sel, want daar is M2 waarde nog niet gecorrigeerd met xfac (kan ook uit f_i_HAT komen maar daar zit M2 niet per definitie in)
        else: # HET IS EEN KNOOPAFHANKELIJKE COMPONENT (F#1)
            f_i_pd.loc[[xfac_const]] = xfac_values[xfac_const]*(f_i_pd.loc[[xfac_const],:]-1)+1 # uit document tom bogaard, en hvufea.f line 181. staat ook in hatyan gebruikershandleiding bij knoopfactoren (pag2-5)

    return f_i_pd</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hatyan" href="index.html">hatyan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hatyan.schureman.get_schureman_table" href="#hatyan.schureman.get_schureman_table">get_schureman_table</a></code></li>
<li><code><a title="hatyan.schureman.get_schureman_freqs" href="#hatyan.schureman.get_schureman_freqs">get_schureman_freqs</a></code></li>
<li><code><a title="hatyan.schureman.get_schureman_v0" href="#hatyan.schureman.get_schureman_v0">get_schureman_v0</a></code></li>
<li><code><a title="hatyan.schureman.get_schureman_constants" href="#hatyan.schureman.get_schureman_constants">get_schureman_constants</a></code></li>
<li><code><a title="hatyan.schureman.get_schureman_u" href="#hatyan.schureman.get_schureman_u">get_schureman_u</a></code></li>
<li><code><a title="hatyan.schureman.get_schureman_f" href="#hatyan.schureman.get_schureman_f">get_schureman_f</a></code></li>
<li><code><a title="hatyan.schureman.correct_fwith_xfac" href="#hatyan.schureman.correct_fwith_xfac">correct_fwith_xfac</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>