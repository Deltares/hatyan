<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>hatyan.astrog API documentation</title>
<meta name="description" content="astrog.py contains all astro-related definitions, previously embedded in a separate program but now part of hatyan â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hatyan.astrog</code></h1>
</header>
<section id="section-intro">
<p>astrog.py contains all astro-related definitions, previously embedded in a separate program but now part of hatyan.</p>
<p>hatyan is a Python program for tidal analysis and prediction, based on the FORTRAN version.
Copyright (C) 2019-2020 Rijkswaterstaat.
Maintained by Deltares, contact: Jelmer Veenstra (jelmer.veenstra@deltares.nl).
Source code available at: <a href="https://repos.deltares.nl/repos/lib_tide/trunk/src/hatyan_python/hatyan">https://repos.deltares.nl/repos/lib_tide/trunk/src/hatyan_python/hatyan</a></p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.
If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
astrog.py contains all astro-related definitions, previously embedded in a separate program but now part of hatyan.

hatyan is a Python program for tidal analysis and prediction, based on the FORTRAN version.
Copyright (C) 2019-2020 Rijkswaterstaat.
Maintained by Deltares, contact: Jelmer Veenstra (jelmer.veenstra@deltares.nl).
Source code available at: https://repos.deltares.nl/repos/lib_tide/trunk/src/hatyan_python/hatyan

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;


def astrog_culminations(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates lunar culminations, parallax and declination. By default the lunar culmination is calculated at coordinates 52,0 (Netherlands,Greenwich).

    Parameters
    ----------
    tFirst : pd.Timestamp, datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : pd.Timestamp, datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataCulminations : pandas DataFrame
        datetime:    lunar culmination at Greenwich in UTC (datetime)
        type:        type of culmination (1=lower, 2=upper)
        parallax:    lunar parallax (degrees)
        declination: lunar declination (degrees)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt
    
    from hatyan.hatyan_core import get_hatyan_freqs
    
    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])
    
    # constants
    EHMINC       = 346.8                                            # increment of ephemeris hour angle of moon (deg/day)
    M2_period_hr = get_hatyan_freqs([&#39;M2&#39;]).loc[&#39;M2&#39;,&#39;period [hr]&#39;] # interval between lunar culminations (days)
    
    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(hours=M2_period_hr+1*24)
    date_last = tLast+dt.timedelta(hours=M2_period_hr+1*24)

    # estimate culminations (time and type)
    astrabOutput = astrab(date_first,dT(date_first,mode_dT=mode_dT))
    EHMOON = astrabOutput[&#39;EHMOON&#39;]
    EHMOON[EHMOON&gt;=360] -= 360. #subtract 360 if larger than 360
    # ICUL=1: next culmination is lower culmination
    # ICUL=2: next culmination is upper culmination
    ICUL = (EHMOON[0]/180.).astype(int)+1
    CULEST=pd.date_range(start=date_first+dt.timedelta(days=(180.*ICUL-EHMOON[0])/EHMINC),end=date_last,freq=&#39;%iN&#39;%(M2_period_hr*3600*1e9)) #defined freq as M2_period in nanoseconds
    CULTYP = np.empty((len(CULEST),)).astype(int)
    CULTYP[::2]  = ICUL
    CULTYP[1::2] = (ICUL%2)+1
    
    # calculate exact time of culminations
    CULTIM = astrac(CULEST,dT(CULEST,mode_dT=mode_dT),CULTYP)
    astrabOutput = astrab(CULTIM,dT(CULTIM,mode_dT=mode_dT))
    PAR = astrabOutput[&#39;PARLAX&#39;]/3600.
    DEC = astrabOutput[&#39;DECMOO&#39;]
    
    # make dataframe and crop for requested timeframe
    dataCulminations = pd.DataFrame({&#39;datetime&#39;:CULTIM,&#39;type&#39;:CULTYP,&#39;parallax&#39;:PAR,&#39;declination&#39;:DEC}) #CULTIM.round(&#39;S&#39;) decreases fortran reproduction
    dataCulminations[&#39;type_str&#39;] = dataCulminations[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;lowerculmination&#39;).replace(&#39;2&#39;,&#39;upperculmination&#39;)
    dataCulminations[&#39;datetime&#39;] = pd.to_datetime(dataCulminations[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone to UTC
    dataCulminations[&#39;datetime&#39;] = dataCulminations[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone
    
    #filter datetimerange
    dataCulminations_dtnaive = dataCulminations[&#39;datetime&#39;].dt.tz_localize(None)
    dataCulminations = dataCulminations[np.logical_and(dataCulminations_dtnaive&gt;=tFirst,dataCulminations_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataCulminations







def astrog_phases(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates lunar phases. The lunar phases are independent of coordinates.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataPhases : pandas DataFrame
        datetime:  lunar phase in UTC (datetime)
        type:      type of phase (1=FQ, 2=FM, 3=LQ, 4=NM)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])
        
    # constants
    ELOINC = 12.2           # increment of ecliptic elongation of moon-sun (deg/day)
    FASINT = 29.530587981/4 # quarter of a lunar synodic month (days)

    # first and last datetime in calculation (add enough margin (done later), and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(days=FASINT+1)
    date_last = tLast+dt.timedelta(days=FASINT+1)

    # estimate first lunar phase (time and type), correct first date (FAEST_first to 45 deg from there)
    astrabOutput = astrab(date_first,dT(date_first,mode_dT=mode_dT))
    ELONG = astrabOutput[&#39;ELONG&#39;]
    ELONG[ELONG&gt;=360] -= 360.
    FAEST_first = date_first - pd.TimedeltaIndex((ELONG-45)%360/ELOINC, unit=&#39;D&#39;)

    # use the first date to create a new daterange from the correct starting time. The frequency is 29 days, 12 hours and 44 minutes, following from dood_S-dood_H
    date = pd.date_range(start=FAEST_first[0],end=date_last,freq=&#39;%iN&#39;%(FASINT*24*3600*1e9))

    # estimate all lunar phases (time and type)
    astrabOutput = astrab(date,dT(date,mode_dT=mode_dT))
    ELONG = astrabOutput[&#39;ELONG&#39;]
    ELONG[ELONG&gt;=360] -= 360.
    FATYP=(np.array(ELONG/90.).astype(int)+3)%4+1 #make sure the next phase is searched for (modulus to use &#39;FATYP-1&#39;)
    FAEST=date-pd.TimedeltaIndex((90.*FATYP-ELONG)/ELOINC, unit=&#39;D&#39;)

    # calculate exact time of phase, loop until date_last
    TIMDIF = pd.TimedeltaIndex(-dT(FAEST,mode_dT=mode_dT)+1./2880.,unit=&#39;D&#39;)
    FATIM = astrac(FAEST,dT(FAEST,mode_dT=mode_dT),FATYP+2)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataPhases = pd.DataFrame({&#39;datetime&#39;:FATIM.round(&#39;S&#39;),&#39;type&#39;:FATYP})
    dataPhases[&#39;type_str&#39;] = dataPhases[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;FQ&#39;).replace(&#39;2&#39;,&#39;FM&#39;).replace(&#39;3&#39;,&#39;LQ&#39;).replace(&#39;4&#39;,&#39;NM&#39;)
    dataPhases[&#39;datetime&#39;] = pd.to_datetime(dataPhases[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataPhases[&#39;datetime&#39;] = dataPhases[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone
    if (np.diff(dataPhases.sort_values(&#39;datetime&#39;).index)!=1).any():
        raise Exception(&#39;something went wrong with moonphases which resulted in off ordering of the dataframe, check FAEST_first degree correction&#39;)
    
    #filter datetimerange
    dataPhases_dtnaive = dataPhases[&#39;datetime&#39;].dt.tz_localize(None)
    dataPhases = dataPhases[np.logical_and(dataPhases_dtnaive&gt;=tFirst,dataPhases_dtnaive&lt;=tLast)].reset_index(drop=True)

    return dataPhases





def astrog_sunriseset(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates sunrise and -set at requested location.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.
    lon : float, optional
        Longitude, defined positive eastward. The default is -5.3876 (Amersfoort).
    lat : float, optional
        Latitude, defined positive northward, cannot exceed 59 (too close to poles). The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataSun : pandas DataFrame
        datetime: time of rise or set in UTC (datetime)
        type:     type  (1=sunrise, 2=sunset)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst.date()-dt.timedelta(days=1)
    date_last = tLast.date()+dt.timedelta(days=1)

    # --- sunrise and -set ---
    # estimate times: starting at tFirst, 0h local solar time
    OPEST  = pd.date_range(start=date_first+dt.timedelta(days=-lon/180/24.+.25),end=date_last,freq=&#39;%iN&#39;%(24*3600*1e9)) # &#39;floor&#39; date to 00:00 +6h
    ONEST  = pd.date_range(start=date_first+dt.timedelta(days=-lon/180/24.+.75),end=date_last,freq=&#39;%iN&#39;%(24*3600*1e9)) # &#39;floor&#39; date to 00:00 +18h

    # calculate exact times
    TIMDIF = pd.TimedeltaIndex(-dT(OPEST,mode_dT=mode_dT)+1./2880.,unit=&#39;D&#39;)
    OPTIM  = astrac(OPEST,dT(OPEST,mode_dT=mode_dT),np.array( 9),lon=lon,lat=lat)+TIMDIF
    ONTIM  = astrac(ONEST,dT(ONEST,mode_dT=mode_dT),np.array(10),lon=lon,lat=lat)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataSun = pd.DataFrame({&#39;datetime&#39;:np.concatenate((OPTIM.round(&#39;S&#39;),ONTIM.round(&#39;S&#39;))),&#39;type&#39;:np.concatenate((np.full(len(OPTIM),1),np.full(len(OPTIM),2)))})
    dataSun = dataSun.sort_values(&#39;datetime&#39;).reset_index(drop=True)
    dataSun[&#39;type_str&#39;] = dataSun[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;sunrise&#39;).replace(&#39;2&#39;,&#39;sunset&#39;)
    dataSun[&#39;datetime&#39;] = pd.to_datetime(dataSun[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataSun[&#39;datetime&#39;] = dataSun[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataSun_dtnaive = dataSun[&#39;datetime&#39;].dt.tz_localize(None)
    dataSun = dataSun[np.logical_and(dataSun_dtnaive&gt;=tFirst,dataSun_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataSun






def astrog_moonriseset(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates moonrise and -set at requested location.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.
    lon : float, optional
        Longitude, defined positive eastward. The default is -5.3876 (Amersfoort).
    lat : float, optional
        Latitude, defined positive northward, cannot exceed 59 (too close to poles). The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataMoon : pandas DataFrame
        datetime: time of rise or set in UTC (datetime)
        type:     type  (1=moonrise, 2=moonset)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # constants
    from hatyan.hatyan_core import get_hatyan_freqs
    M2_period_hr = get_hatyan_freqs([&#39;M2&#39;]).loc[&#39;M2&#39;,&#39;period [hr]&#39;] # CULINT
    EHMINC = 346.8 # increment of ephemeris hour angle of moon (deg/day)

    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(hours=M2_period_hr+1*24)
    date_last = tLast+dt.timedelta(hours=M2_period_hr+1*24)

    # --- moonrise and -set ---
    # estimate times
    astrabOutput=astrab(date_first,dT(date_first,mode_dT=mode_dT),lon=lon,lat=lat)
    ALTMOO=astrabOutput[&#39;ALTMOO&#39;]
    EHMOON=astrabOutput[&#39;EHMOON&#39;]
    # first phenomenon is moonrise
    if ALTMOO &lt; -(0.5667+(0.08+0.2725*astrabOutput[&#39;PARLAX&#39;])/3600.):
        OPEST=pd.date_range(start=date_first+dt.timedelta(days=(270.-EHMOON[0])/EHMINC),end=date_last,freq=&#39;%iN&#39;%(M2_period_hr*2*3600*1e9))
        ONEST=OPEST+dt.timedelta(hours=M2_period_hr)
    # first phenomenon is moonset
    else:
        ONEST=pd.date_range(start=date_first+dt.timedelta(days=(90.-EHMOON[0])/EHMINC),end=date_last,freq=&#39;%iN&#39;%(M2_period_hr*2*3600*1e9))
        OPEST=ONEST+dt.timedelta(hours=M2_period_hr)

    # calculate exact times
    TIMDIF = pd.TimedeltaIndex(-dT(OPEST,mode_dT=mode_dT)+1./2880.,unit=&#39;D&#39;)
    OPTIM  = astrac(OPEST,dT(OPEST,mode_dT=mode_dT),np.array(7),lon=lon,lat=lat)+TIMDIF
    ONTIM  = astrac(ONEST,dT(ONEST,mode_dT=mode_dT),np.array(8),lon=lon,lat=lat)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataMoon = {&#39;datetime&#39;:np.concatenate((OPTIM.round(&#39;S&#39;),ONTIM.round(&#39;S&#39;))),&#39;type&#39;:np.concatenate((np.full(len(OPTIM),1),np.full(len(OPTIM),2)))}
    dataMoon = pd.DataFrame(dataMoon).sort_values(&#39;datetime&#39;).reset_index(drop=True)
    dataMoon[&#39;type_str&#39;] = dataMoon[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;moonrise&#39;).replace(&#39;2&#39;,&#39;moonset&#39;)
    dataMoon[&#39;datetime&#39;] = pd.to_datetime(dataMoon[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataMoon[&#39;datetime&#39;] = dataMoon[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataMoon_dtnaive = dataMoon[&#39;datetime&#39;].dt.tz_localize(None)
    dataMoon = dataMoon[np.logical_and(dataMoon_dtnaive&gt;=tFirst,dataMoon_dtnaive&lt;=tLast)].reset_index(drop=True)

    return dataMoon





def astrog_anomalies(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates lunar anomalies. The lunar anomalies are independent of coordinates.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataAnomaly : pandas DataFrame
        datetime:   lunar anomaly in UTC (datetime)
        type:       type of anomaly (1=perigeum, 2=apogeum)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # constants
    ANMINC   = 13.06       # increment of anomaly of moon (deg/day)
    ANOINT   = 27.554551/2 # half of a lunar anomalistic month (days)

    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(days=ANOINT+1)
    date_last = tLast+dt.timedelta(days=ANOINT+1)

    # estimate first lunar anomaly (time and type)
    astrabOutput=astrab(date_first,dT(date_first,mode_dT=mode_dT))
    DPAXDT=astrabOutput[&#39;DPAXDT&#39;]
    ANM   =astrabOutput[&#39;ANM&#39;]
    if DPAXDT&gt;0.:
        # ANOTYP=1: perigeum first
        if ANM&lt;90.:
            ANM=ANM+360.
        ANOEST = pd.date_range(start=date_first+dt.timedelta(days=(360.-ANM[0])/ANMINC),end=date_last,freq=&#39;%iN&#39;%(ANOINT*24*3600*1e9))
        ANOTYP = np.empty((len(ANOEST),)).astype(int)
        ANOTYP[::2]  = 1
        ANOTYP[1::2] = 2

    elif DPAXDT&lt;=0.:
        # ANOTYP=2: apogeum first
        if ANM&gt;270.:
            ANM=ANM-360.
        ANOEST = pd.date_range(start=date_first+dt.timedelta(days=(180.-ANM[0])/ANMINC),end=date_last,freq=&#39;%iN&#39;%(ANOINT*24*3600*1e9))
        ANOTYP = np.empty((len(ANOEST),)).astype(int)
        ANOTYP[::2]  = 2
        ANOTYP[1::2] = 1

    # calculate exact times
    TIMDIF = pd.TimedeltaIndex(-dT(ANOEST,mode_dT=mode_dT)+1./48., unit=&#39;D&#39;)
    ANOTIM = astrac(ANOEST,dT(ANOEST,mode_dT=mode_dT),ANOTYP+14)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataAnomaly = pd.DataFrame({&#39;datetime&#39;:ANOTIM.round(&#39;S&#39;),&#39;type&#39;:ANOTYP})
    dataAnomaly[&#39;type_str&#39;] = dataAnomaly[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;perigeum&#39;).replace(&#39;2&#39;,&#39;apogeum&#39;)
    dataAnomaly[&#39;datetime&#39;] = pd.to_datetime(dataAnomaly[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataAnomaly[&#39;datetime&#39;] = dataAnomaly[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataAnomaly_dtnaive = dataAnomaly[&#39;datetime&#39;].dt.tz_localize(None)
    dataAnomaly = dataAnomaly[np.logical_and(dataAnomaly_dtnaive&gt;=tFirst,dataAnomaly_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataAnomaly







def astrog_seasons(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates astronomical seasons. The seasons are independent of coordinates.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataSeasons : pandas DataFrame
        datetime:   start of astronomical season in UTC (datetime)
        type:       type of astronomical season (1=spring, 2=summer, 3=autumn, 4=winter)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # estimate start of seasons (time and type)
    SEIEST = pd.date_range(start=dt.datetime(tFirst.year,int(np.ceil(tFirst.month/3)*3),1),end=tLast+dt.timedelta(days=1),freq=&#39;%iMS&#39;%(3))+dt.timedelta(days=20)
    SEITYP = (SEIEST.month/3).astype(int)

    # calculate exact times, loop until tLast
    TIMDIF = pd.TimedeltaIndex(-dT(SEIEST,mode_dT=mode_dT)+1./2880., unit=&#39;D&#39;) # conversion to UTC
    SEITIM = astrac(SEIEST,dT(SEIEST,mode_dT=mode_dT),SEITYP+10)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataSeasons = pd.DataFrame({&#39;datetime&#39;:SEITIM.round(&#39;S&#39;),&#39;type&#39;:SEITYP})
    dataSeasons[&#39;type_str&#39;] = dataSeasons[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;spring&#39;).replace(&#39;2&#39;,&#39;summer&#39;).replace(&#39;3&#39;,&#39;autumn&#39;).replace(&#39;4&#39;,&#39;winter&#39;)
    dataSeasons[&#39;datetime&#39;] = pd.to_datetime(dataSeasons[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataSeasons[&#39;datetime&#39;] = dataSeasons[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataSeasons_dtnaive = dataSeasons[&#39;datetime&#39;].dt.tz_localize(None)
    dataSeasons = dataSeasons[np.logical_and(dataSeasons_dtnaive&gt;=tFirst,dataSeasons_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataSeasons






def astrab(date,dT_TT,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Python version of astrab.f in FORTRAN 77
    Calculates 18 astronomical parameters at requested time.

    Parameters
    ----------
    date : datetime.datetime or pandas.DatetimeIndex
        Requested time for calculation.
    dT_TT : float
        Difference between terrestrial and universal time in days.
    lon : float, optional
        Longitude for altitudes, defined positive eastward. The default is 5.3876 (Amersfoort).
    lat : float, optional
        Latitude for altitudes, defined positive northward. The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks if input is valid.

    Returns
    -------
    astrabOutput : dictionary
        18 astronomical variables:
            EHMOON, lunar ephemeris hour angle (degrees between +90 and +450)
            DECMOO, lunar declination (degrees)
            PARLAX, lunar horizontal parallax (arcseconds)
            DPAXDT, time derivative of parallax (arcseconds/day)
            ALTMOO, lunar altitude (degrees, negative below horizon)
            ELONG,  ecliptic elongation moon-sun (degrees, between +45 and +405)
            ALTSUN, solar altitude (degrees, negative under horizon)
            LONSUN, solar longitude (degrees, between 45 and 405)
            EQELON, equatorial elongaton moon-sun (degrees, between 0 and 360)
            DECSUN, solar declination (degrees)
            DISSUN, relative distance earth-sun (astronomical units)
            EHARI,  ephemeris hour angle vernal equinox (degrees, between 0 and 360)
            RASUN,  solar right ascension (degrees, between 0 and 360)
            EHSUN,  solar ephemeris hour angle (degrees, between 0 and 360)
            LONMOO, lunar longitude (degrees, between 0 and 360)
            LATMOO, lunar latitude (degrees)
            RAMOON, lunar right ascension (degrees, between 0 and 360)
            ANM,    mean lunar anomaly (degrees, between 0 and 360)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt


    # check input
    if isinstance(date, pd.DatetimeIndex):
        pass
    elif isinstance(date, dt.datetime):
        date = pd.DatetimeIndex([date])
    else:
        raise Exception(&#39;Input variable date should be datetime or pd.DateTimeIndex&#39;)

    if np.abs(lon)&gt;180:
        raise Exception(&#39;Input variable longitude larger than 180deg&#39;)
    if np.abs(lat)&gt;90:
        raise Exception(&#39;Input variable latitude larger than 90deg&#39;)

    # constants - general
    EPOCH  = dt.datetime(1899, 12, 31, 12, 0, 0) # 1900.0 # -12h shift because julian date 0 is at noon?
    # The average orbital elements of the celestial bodies are calculated for the epoch 1900.0.
    # The values are corrected for the year 1990. Intitial values are from the vernal equinox.

    # constants - sun
    LABOS  = 4.8816237     # longitude sun (rad)
    NSUN   = 0.01720279153 # increment longitude sun (rad/day)
    PEROS  = 4.9082230     # longitude perigeum sun (rad)
    BETSUN = 8.2188819E-7  # increment longitude perigeum sun (rad/day)

    # constants - moon
    LABOM  = 4.7199860     # longitude moon (rad)
    NMOON  = 0.2299715020  # increment longitude moon (rad/day)
    PEROM  = 5.8352992     # longitude perigeum moon (rad)
    BETMOO = 0.0019443591  # increment longitude perigeum moon (rad/day)
    NODOM  = 4.523572      # longitude lunar orbital node lunar (rad)
    GAMMOO =-9.2421851E-4  # increment longitude lunar orbital node lunar (rad/day)
    INMOON = 0.089804108   # inclination lunar orbit (rad)
    PARMEA = 3422.608      # mean horizontal lunar parallax (arcseconds)

    # constants - planets
    VENTZE = 1.10079       # elongation Venus-Earth (rad)
    VENTIN = 0.010760328   # increment elongation Venus-Earth (rad/day)
    TJUPZE = 3.86848       # elongation Earth-Jupiter (rad)
    TJUPIN = 0.015751909   # increment elongation Earth-Jupiter (rad/day)
    TMARZE = 2.89636       # elongation Earth-Mars (rad)
    TMARIN = 0.008056024   # increment elongation Earth-Mars (rad/day)
    TSATZE = 3.37079       # elongation Earth-Saturnus (rad)
    TSATIN = 0.016618143   # increment elongation Earth-Saturnus (rad/day)

    # constants - ecliptic
    OBZERO = 0.40931977    # inclination of ecliptic (rad)
    OBINC  =-6.21937E-9    # increment inclination of ecliptic (rad/day)

    # constants - vernal equinox
    ARZERO = 4.881523      # ephemeris hour angle of vernal equinox (rad)
    NARIES = 6.30038809878 # increment ephemeris hour angle of vernal equinox (rad/day)

    # constants - lunar orbital disturbances
    # selected from Brown&#39;s Tables of the Motion of the Moon (1909)
    # in longitude
    distP = {&#39;col1&#39;:[        0,            0,            1,            1,        1,        1,            1,            0,            0,            0,            0,            0,            2,            2,            2,            2,            1,            1,            1,            1,            1,            1,            1,            0,            0,            0,            0,            0,            1,            1,            1,            0,            3,            3,            3,            3,            2,            2,            2,            2,            2,            2,            1,            1,            1,            1,            1,            1,            1,            1,            1,            0,            0,            2,            2,            1,            1,            4,            4,            2,            2],
             &#39;col2&#39;:[        0,            0,            0,            0,        0,        0,            0,            1,            1,            1,            1,            0,            0,            0,            0,            0,            1,            1,            1,            1,           -1,           -1,           -1,            2,            2,            0,            0,            0,            0,            0,            0,            1,            0,            0,            0,            0,            1,            1,            1,           -1,           -1,           -1,            2,            2,           -2,           -2,            0,            0,            0,            0,            0,            1,            1,            0,            0,            1,           -1,            0,            0,            0,            0],
             &#39;col3&#39;:[        0,            0,            0,            0,        0,        0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            2,            2,            2,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            2,            2,           -2,           -2,           -2,            2,           -2,            0,            0,            0,            0,            0,            0,            2,           -2],
             &#39;col4&#39;:[        4,            2,            4,            2,        0,       -2,           -4,            2,            0,           -2,           -4,            1,            2,            0,           -2,           -4,            2,            0,           -2,           -4,            2,            0,           -2,            0,           -2,            2,            0,           -2,            1,           -1,           -3,            1,            2,            0,           -2,           -4,            0,           -2,           -4,            2,            0,           -2,            0,           -2,            0,           -2,            2,            0,            2,            0,           -2,           -2,            2,           -1,           -3,            1,           -1,            0,           -2,            0,            0],
             &#39;col5&#39;:[   13.902,     2369.902,        1.979,      191.953,22639.500,-4586.426,      -38.428,      -24.420,     -666.608,     -164.773,       -1.877,     -125.154,       14.387,      769.016,     -211.656,      -30.773,       -2.921,     -109.420,     -205.499,       -4.391,       14.577,      147.361,       28.475,       -7.486,       -8.096,       -5.741,     -411.608,      -55.173,       -8.466,       18.609,        3.215,       18.023,        1.060,       36.124,      -13.193,       -1.187,       -7.649,       -8.627,       -2.740,        1.181,        9.703,       -2.494,       -1.167,       -7.412,        2.580,        2.533,        -.992,      -45.099,       -6.382,       39.532,        9.366,       -2.152,       -1.440,        1.750,        1.225,        1.267,       -1.089,        1.938,        -.952,       -3.996,       -1.298],}
    distP = pd.DataFrame(distP)
    # in latitude
    distC = {&#39;col1&#39;:[     0,     2,     3,     0,     0,     1,     1,    -1,    -1],
             &#39;col2&#39;:[     0,     0,     0,     1,     2,     1,     1,     1,     1],
             &#39;col3&#39;:[     0,     0,     0,     0,     0,     0,     0,     0,     0],
             &#39;col4&#39;:[     1,    -2,     0,     0,    -2,     2,    -2,     0,    -2],
             &#39;col5&#39;:[ -.725, 5.679,-1.300,-1.302, -.740,  .787, 2.056,  .679,-1.540]}
    distC = pd.DataFrame(distC)
    distS = {&#39;col1&#39;:[       0,       0,       0,       1,       1,       1,       1,       1,       1,       2,       2,       2,       2,       3,       3,       0,       0,       0,       0,       0,       0,       1,       1,       1,       1,      -1,      -1,      -1,       2,       2,       2,       1,       0,       1,      -1],
             &#39;col2&#39;:[       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       1,       1,       1,       1,       1,       2,       1,       1,       1,       1,       1,       1,       1,       1,       1,      -1,       2,       0,       0,       0],
             &#39;col3&#39;:[       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       2,       2,       2],
             &#39;col4&#39;:[       1,       2,       4,       4,       2,       0,      -2,      -3,      -4,       2,       0,      -2,      -4,       0,      -2,       2,       1,       0,      -2,      -4,      -2,       2,       0,      -2,      -4,       2,       0,      -2,       0,      -2,       0,      -2,      -2,      -2,       0],
             &#39;col5&#39;:[ -112.79, 2373.36,   14.06,    6.98,  192.72,22609.07,-4578.13,    5.44,  -38.64,   14.78,  767.96, -152.53,  -34.07,   50.64,  -16.40,  -25.10,   17.93, -126.98, -165.06,   -6.46,  -16.35,  -11.75, -115.18, -182.36,   -9.66,  -23.59, -138.76,  -31.70,  -10.56,   -7.59,   11.67,   -6.12,  -52.14,   -9.52,  -85.13]}
    distS = pd.DataFrame(distS)
    distN = {&#39;col1&#39;:[       0,       0,       1,       1,      -1,      -1,      -2,      -2,       0,       0],
             &#39;col2&#39;:[       0,       0,       0,       0,       0,       0,       0,       0,       1,      -1],
             &#39;col3&#39;:[       1,       1,       1,       1,       1,       1,       1,       1,       1,       1],
             &#39;col4&#39;:[      -2,      -4,      -2,      -4,       0,      -2,       0,      -2,      -2,      -2],
             &#39;col5&#39;:[-526.069,  -3.352,  44.297,  -6.000,  20.599, -30.598, -24.649,  -2.000, -22.571,  10.985]}
    distN = pd.DataFrame(distN)
    # in parallax
    distR = {&#39;col1&#39;:[        0,        0,        1,        1,        1,        1,        0,        0,        0,        0,        2,        2,        2,        2,        1,        1,        1,        1,        1,        0,        1,        0,        3,        3,        2,        2,        1],
             &#39;col2&#39;:[        0,        0,        0,        0,        0,        0,        1,        1,        1,        0,        0,        0,        0,        0,        1,        1,       -1,       -1,       -1,        0,        0,        1,        0,        0,        1,       -1,        0],
             &#39;col3&#39;:[        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        2,        0,        0,        0,        0,        0,        0,       -2],
             &#39;col4&#39;:[        4,        2,        2,        0,       -2,       -4,        2,        0,       -2,        1,        2,        0,       -2,       -4,        0,       -2,        2,        0,       -2,       -2,        1,        1,        0,       -2,        0,        0,        0],
             &#39;col5&#39;:[    .2607,  28.2333,   3.0861, 186.5398,  34.3117,    .6008,   -.2993,   -.3988,   1.9135,   -.9781,    .2833,  10.1657,   -.3039,    .3722,   -.9469,   1.4404,    .2297,   1.1502,   -.2252,   -.1052,   -.1093,    .1494,    .6215,   -.1187,   -.1038,    .1268,   -.7136]}
    distR = pd.DataFrame(distR)

    # process input data
    TIME  = np.array((date-EPOCH).total_seconds()/86400) # days since 1900
    if (TIME&lt;0).any() or (TIME&gt;70000).any():
        raise Exception(&#39;Requested time out of range (1900-2091)&#39;)
    RLONG=-np.deg2rad(lon)
    RLATI= np.deg2rad(lat)

    # mean orbital elements
    # of sun, including additive correction
    LABSUN=(LABOS -np.deg2rad(6.22/3600) +NSUN*TIME) % (2*np.pi)
    PERSUN=PEROS+BETSUN*TIME
    # of moon
    LABMOO=(LABOM+NMOON *TIME) % (2*np.pi)
    PERMOO=(PEROM+BETMOO*TIME) % (2*np.pi)
    NODMOO=NODOM+GAMMOO*TIME
    # additive corrections for moon
    LABMOO=LABMOO+np.deg2rad(( 0.79 +14.27 *np.sin(6.0486+6.34913E-5*TIME)+7.261*np.sin(NODMOO))/3600)
    PERMOO=PERMOO+np.deg2rad((-1.966- 2.076*np.sin(NODMOO))/3600)
    NODMOO=NODMOO+np.deg2rad(( 0.59 +95.96 *np.sin(NODMOO)+15.58*np.sin(NODMOO+4.764400))/3600)
    CINMOO=np.deg2rad((-8.636*np.cos(NODMOO)-1.396*np.cos(NODMOO+4.764400))/3600)

    # mean heliocentric elongation Venus-Earth, Earth-Jupiter, Earth-Mars and Earth-Saturnus
    VENTER=VENTZE+TIME*VENTIN
    TERJUP=TJUPZE+TIME*TJUPIN
    TERMAR=TMARZE+TIME*TMARIN
    TERSAT=TSATZE+TIME*TSATIN

    # Nutation in longitude
    CNULON=-17.248*np.sin(NODMOO)-1.273*np.sin(2.*LABSUN)
    # Nutation in inclination of ecliptic
    CNUTOB=  9.21 *np.cos(NODMOO)+0.55 *np.cos(2.*LABSUN)

    # inclination of ecliptic, sine and cosine of inclination
    OBLIQ=OBZERO+TIME*OBINC+np.deg2rad(CNUTOB/3600)
    SINOB=np.sin(OBLIQ)
    COSOB=np.cos(OBLIQ)

    # parameters of sun and moon for disturbance equations
    ANM=LABMOO-PERMOO # output value 18: mean lunar anomaly (rad)
    ANS=LABSUN-PERSUN
    FNO=LABMOO-NODMOO
    ELO=LABMOO-LABSUN
    DAM=NMOON-BETMOO
    DAS=NSUN-BETSUN
    DFN=NMOON-GAMMOO
    DEL=NMOON-NSUN

    # disturbance equations
    # disturbances in longitude sun
    # equation of center
    CENTR=(6910.10 -17.33*TIME/36525)*np.sin(ANS)+72.01*np.sin(2.*ANS) + 1.05*np.sin(3.*ANS)
    # planetary disturbances
    PLANET= ( 4.838*np.cos(   VENTER       +1.5708)
             +5.526*np.cos(2.*VENTER       +1.5723)
             +0.666*np.cos(3.*VENTER       +4.7195)
             +2.497*np.cos(2.*VENTER   -ANS+4.4986)
             +1.559*np.cos(3.*VENTER   -ANS+1.3607)
             +1.024*np.cos(3.*VENTER-2.*ANS+0.8875)
             +7.208*np.cos(   TERJUP       +1.5898)
             +2.731*np.cos(2.*TERJUP       +4.7168)
             +2.600*np.cos(   TERJUP   -ANS+3.0503)
             +1.610*np.cos(2.*TERJUP   -ANS+5.1068)
             +0.556*np.cos(3.*TERJUP   -ANS+3.0946)
             +2.043*np.cos(2.*TERMAR       +1.5660)
             +1.770*np.cos(2.*TERMAR   -ANS+5.3454)
             +0.585*np.cos(4.*TERMAR-2.*ANS+3.2432)
             +0.500*np.cos(4.*TERMAR   -ANS+5.5317)
             +0.425*np.cos(3.*TERMAR   -ANS+5.5449)
             +0.419*np.cos(   TERSAT       +1.5767)
             +0.320*np.cos(   TERSAT   -ANS+4.5242))
    # geometric disturbance by the moon
    GEOM=6.454*np.sin(ELO)-0.424*np.sin(ELO-ANM)
    # aberration (correction for optical path)
    ABER=-(20.496+.344*np.cos(ANS))
    # longitude sun with all disturbances
    LONSUN=LABSUN+np.deg2rad((CENTR+PLANET+GEOM+CNULON+ABER)/3600) # output value 8: solar longitude (rad)
    # relative distance from sun
    DISSUN=1.000140 - 0.016712*np.cos(ANS) - 0.000140*np.cos(2.*ANS) # output value 11: relative distance earth-sun (astronomical units)
    # longitude moon with all disturbances
    CLONM=0
    for i in range(0,len(distP)):
        CLONM=CLONM+np.sin(distP[&#39;col1&#39;][i]*ANM+distP[&#39;col2&#39;][i]*ANS+distP[&#39;col3&#39;][i]*FNO+distP[&#39;col4&#39;][i]*ELO) * distP[&#39;col5&#39;][i]
    LONMOO=LABMOO+np.deg2rad((CNULON+CLONM)/3600) # output value 15: lunar longitude (rad)
    # latitude moon with all disturbances
    CLM=0
    for i in range(0,len(distC)):
        CLM=CLM+np.cos(distC[&#39;col1&#39;][i]*ANM+distC[&#39;col2&#39;][i]*ANS+distC[&#39;col3&#39;][i]*FNO+distC[&#39;col4&#39;][i]*ELO) * distC[&#39;col5&#39;][i]
    SLM=0
    for i in range(0,len(distS)):
        SLM=SLM+np.sin(distS[&#39;col1&#39;][i]*ANM+distS[&#39;col2&#39;][i]*ANS+distS[&#39;col3&#39;][i]*FNO+distS[&#39;col4&#39;][i]*ELO) * distS[&#39;col5&#39;][i]
    SF=FNO+np.deg2rad(SLM/3600)
    NLM=0
    for i in range(0,len(distN)):
        NLM=NLM+np.sin(distN[&#39;col1&#39;][i]*ANM+distN[&#39;col2&#39;][i]*ANS+distN[&#39;col3&#39;][i]*FNO+distN[&#39;col4&#39;][i]*ELO) * distN[&#39;col5&#39;][i]
    LATMOO=((18519.7+CLM)*np.sin(SF) - 6.241*np.sin(3.*SF) + NLM)*np.deg2rad((1.+CINMOO/INMOON)/3600) # output value 16: lunar latitude (rad)

    # lunar parallax
    PARLAX=PARMEA # output value 3: lunar horizontal parallax (arcseconds)
    for i in range(0,len(distR)):
        PARLAX=PARLAX+np.cos(distR[&#39;col1&#39;][i]*ANM+distR[&#39;col2&#39;][i]*ANS+distR[&#39;col3&#39;][i]*FNO+distR[&#39;col4&#39;][i]*ELO) * distR[&#39;col5&#39;][i]
    # derrivative of lunar parallax
    DPAXDT=0. # output value 4: time derivative of parallax (arcseconds/day)
    for i in range(0,len(distR)):
        DPAXDT=(DPAXDT-np.sin(distR[&#39;col1&#39;][i]*ANM+distR[&#39;col2&#39;][i]*ANS+distR[&#39;col3&#39;][i]*FNO+distR[&#39;col4&#39;][i]*ELO) *
                (distR[&#39;col1&#39;][i]*DAM+distR[&#39;col2&#39;][i]*DAS+distR[&#39;col3&#39;][i]*DFN+distR[&#39;col4&#39;][i]*DEL) * distR[&#39;col5&#39;][i])

    # ecliptic elongation moon-sun
    ELONG=LONMOO-LONSUN # output value 6: ecliptic elongation moon-sun (rad)

    # transformation to equatorial coordinates
    TEMP1=np.sin(LONSUN)
    TEMP2=np.cos(LONSUN)
    RASUN=np.arctan2(TEMP1*COSOB,TEMP2)                          # output value 13: solar right ascension (rad)
    TEMP3=TEMP1*SINOB
    DECSUN=np.arcsin(TEMP3)                                      # output value 10: solar declination (rad)
    TEMP4=np.sin(LONMOO)
    TEMP5=np.cos(LONMOO)
    TEMP6=np.sin(LATMOO)
    TEMP7=np.cos(LATMOO)
    RAMOON=np.arctan2(TEMP7*TEMP4*COSOB-TEMP6*SINOB,TEMP7*TEMP5) # output value 17: lunar right ascension (rad)
    TEMP8=TEMP7*TEMP4*SINOB+TEMP6*COSOB
    DECMOO=np.arcsin(TEMP8)                                      # output value 2: lunar declination (rad)
    EQELON=RAMOON-RASUN                                          # output value 9: equatorial elongaton moon-sun (rad)

    # uurhoeken
    EHARI  =(ARZERO+NARIES*TIME+COSOB*np.deg2rad(CNULON/3600)) % (2*np.pi)    # output value 12: ephemeris hour angle of vernal equinox (rad)
    LHARI  =EHARI-dT_TT*NARIES-RLONG                             # local hour angle of vernal equinox (rad)
    EHSUN  =EHARI-RASUN                                          # output value 14: solar ephemeris hour angle (rad)
    EHMOON =EHARI-RAMOON                                         # output value  1: lunar ephemeris hour angle (rad)
    LHSUN  =LHARI-RASUN                                          # local solar hour angle (rad)
    LHMOON =LHARI-RAMOON                                         # local lunar hour angle (rad)

    # transformation to local coordinates
    ARGUM=TEMP3*np.sin(RLATI)+np.cos(DECSUN)*np.cos(RLATI)*np.cos(LHSUN)
    ALTSUN=np.nan_to_num(np.arcsin(ARGUM),nan=np.copysign(np.pi/2,ARGUM))  # output value 7: solar altitude (rad). Makes use of np.nan_to_num, filling in condition from if-statement
    ARGUM=TEMP8*np.sin(RLATI)+np.cos(DECMOO)*np.cos(RLATI)*np.cos(LHMOON)
    ALTMOO=np.arcsin(ARGUM)
    ALTMOO=np.nan_to_num(ALTMOO-np.cos(ALTMOO)*np.deg2rad(PARLAX/3600),nan=np.copysign(np.pi/2,ARGUM)) # output value 5: lunar altitude (rad). Makes use of np.nan_to_num, filling in condition from if-statement

    # summarize in dataframe and convert output to degrees
    astrabOutput = {&#39;EHMOON&#39;:((np.rad2deg(EHMOON)+ 720.-90.) % 360.)+90.,
                    &#39;DECMOO&#39;:  np.rad2deg(DECMOO),
                    &#39;PARLAX&#39;:  PARLAX,
                    &#39;DPAXDT&#39;:  DPAXDT,
                    &#39;ALTMOO&#39;:  np.rad2deg(ALTMOO),
                    &#39;ELONG&#39; :((np.rad2deg(ELONG )+1080.-45.) % 360.)+45.,
                    &#39;ALTSUN&#39;:  np.rad2deg(ALTSUN),
                    &#39;LONSUN&#39;:((np.rad2deg(LONSUN)+ 720.-45.) % 360.)+45.,
                    &#39;EQELON&#39;: (np.rad2deg(EQELON)+ 720.)     % 360.,
                    &#39;DECSUN&#39;:  np.rad2deg(DECSUN),
                    &#39;DISSUN&#39;:  DISSUN,
                    &#39;EHARI&#39; :  EHARI,
                    &#39;RASUN&#39; : (np.rad2deg(RASUN )+ 360.)     % 360.,
                    &#39;EHSUN&#39; : (np.rad2deg(EHSUN )+ 720.)     % 360.,
                    &#39;LONMOO&#39;: (np.rad2deg(LONMOO)+ 720.)     % 360.,
                    &#39;LATMOO&#39;:  np.rad2deg(LATMOO),
                    &#39;RAMOON&#39;: (np.rad2deg(RAMOON)+ 360.)     % 360.,
                    &#39;ANM&#39;   : (np.rad2deg(ANM)   + 720.)     % 360.}

    return astrabOutput





def astrac(timeEst,dT_TT,mode,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Python version of astrac.f in FORTRAN 77.
    Calculates exact time of requested astronomical phenomenon.

    Parameters
    ----------
    timeEst : datetime.datetime or pandas.DatetimeIndex
        Estimated time for iteration.
    dT_TT : float
        Difference between terrestrial and universal time in days.
    mode : numpy.array of integer(s)
        Requested phenomenon:
            1:  lunar lower culmination (EHMOON=180 deg.)
            2:  lunar upper culmination (EHMOON=360 deg.)
            3:  lunar first quarter (ELONG=90 deg.)
            4:  full moon (ELONG=180 deg.)
            5:  lunar last quarter (ELONG=270 deg.)
            6:  new moon (ELONG=360 deg.)
            7:  moonrise (ALTMOO=-34 BOOGMIN-SEMIDIAM., ascending)
            8:  moonset (ALTMOO=-34 BOOGMIN-SEMIDIAM., descending)
            9:  sunrise (ALTSUN=-50 arcseconds, ascending)
            10: sunset (ALTSUN=-50 arcseconds, descending)
            11: vernal equinox (LONSUN=360 deg.)
            12: summer solstice (LONSUN=90 deg.)
            13: autumnal equinox (LONSUN=180 deg.)
            14: winter solstice (LONSUN=270 deg.)
            15: perigeum (DPAXDT=0, descending)
            16: apogeum (DPAXDT=0, ascending)
    lon : float, optional
        Longitude for rise and set, defined positive eastward. The default is 5.3876 (Amersfoort).
    lat : float, optional
        Latitude for rise and set, defined positive northward, cannot exceed 59 for modes 7 to 10 (too close to poles). The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks if latitude is not too close to poles.

    Returns
    -------
    TIMOUT : datetime
        Exact time after iteration.

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    if isinstance(timeEst, pd.DatetimeIndex):
        pass
    elif isinstance(timeEst, dt.datetime):
        timeEst = pd.DatetimeIndex([timeEst])
    else:
        raise Exception(&#39;Input variable date should be datetime or pd.DateTimeIndex&#39;)

    # constants - iteration targets
    ANGLE  = np.array([180.   , 360.   , 90.    , 180.    ,   270.  , 360.    ,   -.5667,    -.5667,     -.8333,     -.8333, 360.     , 90.     , 180.     , 270.     ,   0.   ,  0.   ])
    CRITER = np.array([  0.001,   0.001,  0.0001,   0.0001,   0.0001,   0.0001,   0.0002,    0.0002,     0.0002,     0.0002,   0.00001,  0.00001,   0.00001,   0.00001,   0.002,  0.002])
    RAT    = np.array([346.8  , 346.8  , 12.2   ,  12.2   ,    12.2 ,  12.2   , 346.8   , -346.8   ,   360.    ,  -360.    ,   1.     ,  1.     ,   1.     ,   1.     , -10.08 , 10.08 ])
    ANG =ANGLE [mode-1] # required value after iteration
    CRIT=CRITER[mode-1] # allowed difference between ANG and iteration result
    RATE=RAT   [mode-1] # estimated change per day for iteration
    if (mode&gt;=7).any() and (mode&lt;=10).any(): # correct RATE in case of rise and set for latitude
        if np.abs(lat)&gt;59:
            raise Exception(&#39;Latitude to close to poles (&gt;59deg), cannot take polar days and nights into account&#39;)
        RATE=RATE*np.cos(np.deg2rad(lat))

    # define astrab output parameter corresponding to requested mode
    if   ((mode== 1) | (mode== 2)).all():
        IPAR = &#39;EHMOON&#39;
    elif ((mode&gt;= 3) &amp; (mode&lt;= 6)).all():
        IPAR = &#39;ELONG&#39;
    elif ((mode&gt;= 7) &amp; (mode&lt;= 8)).all():
        IPAR = &#39;ALTMOO&#39;
    elif ((mode&gt;= 9) &amp; (mode&lt;=10)).all():
        IPAR = &#39;ALTSUN&#39;
    elif ((mode&gt;=11) &amp; (mode&lt;=14)).all():
        IPAR = &#39;LONSUN&#39;
    elif ((mode&gt;=15) &amp; (mode&lt;=16)).all():
        IPAR = &#39;DPAXDT&#39;
    else:
        raise Exception(&#39;Requested mode (%s) not recognized&#39; % mode)

    # calculate value at start of iteration
    TNEW=timeEst
    astrabOutput = astrab(TNEW,dT_TT,lon=lon,lat=lat)
    PNEW=astrabOutput[IPAR]

    # iterate until criterium is reached or max 20 times
    ITER=1
    while (abs(ANG-PNEW) &gt; CRIT).any():# and ITER &lt;=20:
        TOLD=TNEW
        POLD=PNEW
        if (mode==7).any() or (mode==8).any(): # correction for semidiameter moon
            ANG=ANGLE[mode-1]-(0.08+0.2725*astrabOutput[&#39;PARLAX&#39;])/3600.
        TNEW=TOLD+pd.TimedeltaIndex(np.nan_to_num((ANG-POLD)/RATE),unit=&#39;D&#39;) #nan_to_num to make sure no NaT output in next iteration
        astrabOutput = astrab(TNEW,dT_TT,lon=lon,lat=lat)
        ITER=ITER+1
        PNEW=astrabOutput[IPAR]
        RATE=np.array((PNEW-POLD)/((TNEW-TOLD).total_seconds()/86400))
        if ITER&gt;20:
            raise Exception(&#39;Stopped after %s iterations, datetime=%s&#39; %(ITER-1,TNEW))
    TIMOUT=TNEW#.round(&#39;S&#39;) # rounding everything to seconds reduces the accuracy of the reporduction of FORTRAN culmination times

    return TIMOUT






def dT(dateIn,mode_dT=&#39;exact&#39;):
    &#34;&#34;&#34;
    Calculates difference between terrestrial time and universal time.
    Current hard-coded values valid until 2023, update arrays afterwards.

    Parameters
    ----------
    dateIn : datetime.datetime or pandas.DatetimeIndex
        Date for correction. Definition makes use of provided year.
    mode : string, optional
        &#39;last&#39;: using the last hard-coded value (as last FORTRAN version)
        &#39;historical&#39;: using all (previous) hard-coded values (historical FORTRAN versions)
        &#39;exact&#39; (default): determine dT based on number of leap seconds (follows international definition)

    Raises
    ------
    Warning
        Checks if hard-coded values can still be used.

    Returns
    -------
    dT_TT : float
        Difference dT between terrestrial time (TT) and universal time (UT1) in seconds

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    if isinstance(dateIn, pd.DatetimeIndex):
        pass
    elif isinstance(dateIn, dt.datetime):
        dateIn = pd.DatetimeIndex([dateIn])
    else:
        raise Exception(&#39;Input variable date should be datetime or pd.DateTimeIndex&#39;)

    if mode_dT==&#39;last&#39; or mode_dT==&#39;historical&#39;: # use approximation of dT based on hard-coded values
        # historical hard-coded values (taken from FORTRAN comments) from Astronomical Almanac - Reduction of time scales
        dT_TTyear     = [ 1980,  1993,  2002,  2012 ] # year of used dT_TTval value
        dT_TTval      = [50.97, 59.35, 64.90, 67.184] # difference between TT and UT1 (32.184s + leap seconds)
        dT_TTinc      = [0.998,  0.70,  0.42,  0.676] # yearly increment of dT curve: (dT_last-dT_5yBefore)/5
        if (dateIn.year&gt;dT_TTyear[-1]+11).any(): # check if the last hard-coded value can still be used
            print(&#39;WARNING: update hard-coded arrays in definition dT to continue using astrog for modes &#34;last&#34; and &#34;historical&#34;&#39;)
        #SCL: changed way to set ind to work with pandas DatetimeIndex
        ind = np.full(len(dateIn),-1) # use the last hard-coded value (same result as last available FORTRAN version)
        if mode_dT==&#39;historical&#39;: # use the historical hard-coded values to reproduce results from older FORTRAN versions
            ind[dateIn&lt;dt.datetime(2013,10, 1)]=2
            ind[dateIn&lt;dt.datetime(2001,11,22)]=1
            ind[dateIn&lt;dt.datetime(1994, 8,23)]=0
        dT_TTyear = list(map(dT_TTyear.__getitem__, ind))
        dT_TTval  = list(map(dT_TTval.__getitem__,  ind))
        dT_TTinc  = list(map(dT_TTinc.__getitem__,  ind))

        # approximation of dT in requested year (dT = TT-UT1)
        dT_TT = (dT_TTval+dT_TTinc*(np.array(dateIn.year)-dT_TTyear))/86400 # approximation of dT_TT in [year]

    elif mode_dT==&#39;exact&#39;:
        # hard-coded list with leap seconds
        NTP = {&#39;1972-01-01&#39;:10,
               &#39;1972-07-01&#39;:11,
               &#39;1973-01-01&#39;:12,
               &#39;1974-01-01&#39;:13,
               &#39;1975-01-01&#39;:14,
               &#39;1976-01-01&#39;:15,
               &#39;1977-01-01&#39;:16,
               &#39;1978-01-01&#39;:17,
               &#39;1979-01-01&#39;:18,
               &#39;1980-01-01&#39;:19,
               &#39;1981-07-01&#39;:20,
               &#39;1982-07-01&#39;:21,
               &#39;1983-07-01&#39;:22,
               &#39;1985-07-01&#39;:23,
               &#39;1988-01-01&#39;:24,
               &#39;1990-01-01&#39;:25,
               &#39;1991-01-01&#39;:26,
               &#39;1992-07-01&#39;:27,
               &#39;1993-07-01&#39;:28,
               &#39;1994-07-01&#39;:29,
               &#39;1996-01-01&#39;:30,
               &#39;1997-07-01&#39;:31,
               &#39;1999-01-01&#39;:32,
               &#39;2006-01-01&#39;:33,
               &#39;2009-01-01&#39;:34,
               &#39;2012-07-01&#39;:35,
               &#39;2015-07-01&#39;:36,
               &#39;2017-01-01&#39;:37,
               }
        NTP_valid = dt.datetime(2021, 12, 28) #display warning after this date

        NTP_date = [dt.datetime.strptime(x,&#39;%Y-%m-%d&#39;) for x in [*NTP]]
        leap_sec = list(NTP.values())
        ind = np.full(len(dateIn),-1)
        for iD in range(len(NTP_date)-2,-1,-1):
            ind[dateIn&lt;NTP_date[iD]]=iD
        dT_TT  = (np.array(32.184) + list(map(leap_sec.__getitem__,  ind)) )/86400

        if (dateIn&gt;NTP_valid).any():
            print(&#39;WARNING: hard-coded leap-second dataset is officially valid for dates up to %s for mode &#34;exact&#34;. After this date, Astrog extrapolates based on last available leap-second values. To update the dataset, check: https://www.ietf.org/timezones/data/leap-seconds.list&#39;%(NTP_valid.date()))
            leap_sec_5yBefore = leap_sec[np.where(np.array(NTP_date)&lt;NTP_valid-dt.timedelta(days=370*5))[0][-1]]
            dT_TTyear = NTP_valid.year
            dT_TTval  = leap_sec[-1]
            dT_TTinc  = (dT_TTval-leap_sec_5yBefore)/5
            # approximation of dT in requested year (dT = TT-UT1)
            dT_TT_extrapolated = (np.array(32.184) + dT_TTval+dT_TTinc*(np.array(dateIn.year)-dT_TTyear))/86400
            dT_TT[np.array(dateIn.year)-dT_TTyear&gt;0] = dT_TT_extrapolated[np.array(dateIn.year)-dT_TTyear&gt;0]

    else:
        raise Exception(&#39;mode=%s not recognized&#39;%(mode_dT))

    return dT_TT





def convert_str2datetime(datetime_in_list):
    &#34;&#34;&#34;
    Tries to convert datetime_in_list (list of str or datetime.datetime) to list of datetime.datetime

    Parameters
    ----------
    datetime_in_list : list of str/dt.datetime/pd.Timestamp
        DESCRIPTION.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    datetime_out_list : list of pd.Timestamp
        DESCRIPTION.

    &#34;&#34;&#34;
    import datetime as dt
    import pandas as pd

    datetime_out_list = datetime_in_list
    for iDT, datetime_in in enumerate(datetime_in_list):
        if isinstance(datetime_in,pd._libs.tslibs.timestamps.Timestamp):
            datetime_out = datetime_in
        elif isinstance(datetime_in, dt.datetime):
            datetime_out = pd.Timestamp(datetime_in)
            if hasattr(datetime_out,&#39;tz&#39;):
                if datetime_out.tz != None:
                    raise Exception(&#39;tFirst and tLast should be timezone naive dt.datetime or &#34;yyyymmdd&#34; str&#39;)
        else:
            try:
                datetime_out = dt.datetime.strptime(datetime_in,&#39;%Y%m%d&#39;)
            except:
                raise Exception(&#39;date_input should be timezone naive dt.datetime or &#34;yyyymmdd&#34; str&#39;)
                
    return datetime_out_list






def convert2perday(dataframeIn, timeformat=&#39;%H:%M %Z&#39;):
    &#34;&#34;&#34;
    converts normal astrog pd.DataFrame to one with the same information restructured per day

    Parameters
    ----------
    dataframeIn : pd.DataFrame
        with columns &#39;datetime&#39; and &#39;type_str&#39;.
    timeformat : str, optional
        format of the timestrings in dataframeOut. The default is &#39;%H:%M %Z&#39;.

    Returns
    -------
    dataframeOut : pd.DataFrame 
        The &#39;datetime&#39; column contains dates, with columns containing all unique &#39;type_str&#39; values.

    &#34;&#34;&#34;
    
    dataframeOut = dataframeIn.copy()
    dataframeOut.index = dataframeOut[&#39;datetime&#39;].dt.date
    for type_sel in dataframeOut[&#39;type_str&#39;].unique():
        dataframeOut[type_sel] = dataframeOut[&#39;datetime&#39;][dataframeOut[&#39;type_str&#39;]==type_sel].dt.strftime(timeformat)
    dataframeOut.drop([&#39;type&#39;,&#39;type_str&#39;],axis=&#39;columns&#39;,inplace=True)
    dataframeOut = dataframeOut[~dataframeOut.index.duplicated(keep=&#39;first&#39;)]
    dataframeOut[&#39;datetime&#39;] = dataframeOut.index #overwrite datetime with dates
    
    return dataframeOut







def plot_astrog_diff(pd_python, pd_fortran, typeUnit=&#39;-&#39;, typeLab=None, typeBand=None, timeBand=None):
    &#34;&#34;&#34;
    Plots results of FORTRAN and python verison of astrog for visual inspection.
    Top plot shows values or type, middle plot shows time difference, bottom plot shows value/type difference.

    Parameters
    ----------
    pd_python : pandas DataFrame
        DataFrame from astrog (python) with times (UTC).
    pd_fortran : pandas DataFrame
        DataFrame from astrog (FORTRAN) with times (UTC).
    typeUnit : string, optional
        Unit of provided values/types. The default is &#39;-&#39;.
    typeLab : TYPE, optional
        Labels of provided types. The default is [&#39;rise&#39;,&#39;set&#39;].
    typeBand : list of floats, optional
        Expected bandwith of accuracy of values/types. The default is [-.5,.5].
    timeBand : list of floats, optional
        Expected bandwith of accuracy of times (seconds). The default is [0,60].
    timeLim : list of floats, optional
        Time limits of x-axis. The default is None (takes limits from pd_python).

    Returns
    -------
    fig : figure handle
        Output figure.
    axs : axis handles
        Axes in figure.

    &#34;&#34;&#34;
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    
    if hasattr(pd_python[&#39;datetime&#39;].dtype,&#39;tz&#39;):
        pd_python = pd_python.copy() #do not overwrite original dataframe, so make a copy
        pd_python[&#39;datetime&#39;] = pd_python[&#39;datetime&#39;].dt.tz_localize(None) #Passing None will remove the time zone information preserving local time. https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_localize.html#pandas.Series.dt.tz_localize
    
    typeName = pd_python.columns[1]
    fig, (ax1,ax2,ax3) = plt.subplots(3,1,figsize=(15,9),sharex=True)
    ax1.set_title(&#39;%s&#39;%(typeName))
    ax1.plot(pd_python[&#39;datetime&#39;], pd_python[typeName], label=&#39;python&#39;)
    ax1.plot(pd_fortran[&#39;datetime&#39;],pd_fortran[typeName],label=&#39;FORTRAN&#39;,linestyle=&#39;dashed&#39;)
    if typeName == &#39;type&#39;:
        if typeLab is not None:
            ax1.set_ylim(1,len(typeLab))
            ax1.set_yticks(np.arange(1,len(typeLab)+1,step=1))
            ax1.set_yticklabels(typeLab)
    ax1.set_ylabel(&#39;%s [%s]&#39;%(typeName, typeUnit))
    ax1.legend(loc=1)

    ax2.plot(pd_python[&#39;datetime&#39;],(pd_python[&#39;datetime&#39;] - pd.to_datetime(pd_fortran[&#39;datetime&#39;])).dt.total_seconds())
    if timeBand is not None:
        ax2.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[timeBand[0],timeBand[0]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
        ax2.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[timeBand[1],timeBand[1]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
    ax2.set_ylabel(&#39;python - FORTRAN [seconds]&#39;)
    ax2.set_title(&#39;time difference [seconds]&#39;)

    ax3.plot(pd_python[&#39;datetime&#39;],pd_python[typeName] - pd_fortran[typeName])
    if typeBand is not None:
        ax3.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[typeBand[0],typeBand[0]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
        ax3.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[typeBand[1],typeBand[1]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
    ax3.set_ylabel(&#39;python - FORTRAN [%s]&#39;%(typeUnit))
    ax3.set_title(&#39;%s difference [%s]&#39;%(typeName, typeUnit))

    ax1.set_xlim(pd_python[&#39;datetime&#39;].iloc[[0,-1]])
    fig.tight_layout()

    axs = (ax1,ax2,ax3)
    return fig, axs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hatyan.astrog.astrog_culminations"><code class="name flex">
<span>def <span class="ident">astrog_culminations</span></span>(<span>tFirst, tLast, mode_dT='exact', tzone='UTC')</span>
</code></dt>
<dd>
<div class="desc"><p>Makes use of the definitions dT, astrab and astrac.
Calculates lunar culminations, parallax and declination. By default the lunar culmination is calculated at coordinates 52,0 (Netherlands,Greenwich).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tFirst</code></strong> :&ensp;<code>pd.Timestamp, datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>Start of timeframe for output.</dd>
<dt><strong><code>tLast</code></strong> :&ensp;<code>pd.Timestamp, datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>End of timeframe for output.</dd>
<dt><strong><code>mode_dT</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method to calculate difference between universal time and terrestrial time (dT). Can be 'last' (for fortran reproduction), 'historical' or 'exact' (most accurate). The default is 'exact'.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>string/dt.timezone</code>, optional</dt>
<dd>Timezone to convert the output dataset to. The default is 'UTC'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks input times tFirst and tLast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataCulminations</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>datetime:
lunar culmination at Greenwich in UTC (datetime)
type:
type of culmination (1=lower, 2=upper)
parallax:
lunar parallax (degrees)
declination: lunar declination (degrees)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrog_culminations(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates lunar culminations, parallax and declination. By default the lunar culmination is calculated at coordinates 52,0 (Netherlands,Greenwich).

    Parameters
    ----------
    tFirst : pd.Timestamp, datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : pd.Timestamp, datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataCulminations : pandas DataFrame
        datetime:    lunar culmination at Greenwich in UTC (datetime)
        type:        type of culmination (1=lower, 2=upper)
        parallax:    lunar parallax (degrees)
        declination: lunar declination (degrees)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt
    
    from hatyan.hatyan_core import get_hatyan_freqs
    
    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])
    
    # constants
    EHMINC       = 346.8                                            # increment of ephemeris hour angle of moon (deg/day)
    M2_period_hr = get_hatyan_freqs([&#39;M2&#39;]).loc[&#39;M2&#39;,&#39;period [hr]&#39;] # interval between lunar culminations (days)
    
    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(hours=M2_period_hr+1*24)
    date_last = tLast+dt.timedelta(hours=M2_period_hr+1*24)

    # estimate culminations (time and type)
    astrabOutput = astrab(date_first,dT(date_first,mode_dT=mode_dT))
    EHMOON = astrabOutput[&#39;EHMOON&#39;]
    EHMOON[EHMOON&gt;=360] -= 360. #subtract 360 if larger than 360
    # ICUL=1: next culmination is lower culmination
    # ICUL=2: next culmination is upper culmination
    ICUL = (EHMOON[0]/180.).astype(int)+1
    CULEST=pd.date_range(start=date_first+dt.timedelta(days=(180.*ICUL-EHMOON[0])/EHMINC),end=date_last,freq=&#39;%iN&#39;%(M2_period_hr*3600*1e9)) #defined freq as M2_period in nanoseconds
    CULTYP = np.empty((len(CULEST),)).astype(int)
    CULTYP[::2]  = ICUL
    CULTYP[1::2] = (ICUL%2)+1
    
    # calculate exact time of culminations
    CULTIM = astrac(CULEST,dT(CULEST,mode_dT=mode_dT),CULTYP)
    astrabOutput = astrab(CULTIM,dT(CULTIM,mode_dT=mode_dT))
    PAR = astrabOutput[&#39;PARLAX&#39;]/3600.
    DEC = astrabOutput[&#39;DECMOO&#39;]
    
    # make dataframe and crop for requested timeframe
    dataCulminations = pd.DataFrame({&#39;datetime&#39;:CULTIM,&#39;type&#39;:CULTYP,&#39;parallax&#39;:PAR,&#39;declination&#39;:DEC}) #CULTIM.round(&#39;S&#39;) decreases fortran reproduction
    dataCulminations[&#39;type_str&#39;] = dataCulminations[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;lowerculmination&#39;).replace(&#39;2&#39;,&#39;upperculmination&#39;)
    dataCulminations[&#39;datetime&#39;] = pd.to_datetime(dataCulminations[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone to UTC
    dataCulminations[&#39;datetime&#39;] = dataCulminations[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone
    
    #filter datetimerange
    dataCulminations_dtnaive = dataCulminations[&#39;datetime&#39;].dt.tz_localize(None)
    dataCulminations = dataCulminations[np.logical_and(dataCulminations_dtnaive&gt;=tFirst,dataCulminations_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataCulminations</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrog_phases"><code class="name flex">
<span>def <span class="ident">astrog_phases</span></span>(<span>tFirst, tLast, mode_dT='exact', tzone='UTC')</span>
</code></dt>
<dd>
<div class="desc"><p>Makes use of the definitions dT, astrab and astrac.
Calculates lunar phases. The lunar phases are independent of coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tFirst</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>Start of timeframe for output.</dd>
<dt><strong><code>tLast</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>End of timeframe for output.</dd>
<dt><strong><code>mode_dT</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method to calculate difference between universal time and terrestrial time (dT). Can be 'last' (for fortran reproduction), 'historical' or 'exact' (most accurate). The default is 'exact'.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>string/dt.timezone</code>, optional</dt>
<dd>Timezone to convert the output dataset to. The default is 'UTC'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks input times tFirst and tLast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataPhases</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>datetime:
lunar phase in UTC (datetime)
type:
type of phase (1=FQ, 2=FM, 3=LQ, 4=NM)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrog_phases(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates lunar phases. The lunar phases are independent of coordinates.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataPhases : pandas DataFrame
        datetime:  lunar phase in UTC (datetime)
        type:      type of phase (1=FQ, 2=FM, 3=LQ, 4=NM)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])
        
    # constants
    ELOINC = 12.2           # increment of ecliptic elongation of moon-sun (deg/day)
    FASINT = 29.530587981/4 # quarter of a lunar synodic month (days)

    # first and last datetime in calculation (add enough margin (done later), and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(days=FASINT+1)
    date_last = tLast+dt.timedelta(days=FASINT+1)

    # estimate first lunar phase (time and type), correct first date (FAEST_first to 45 deg from there)
    astrabOutput = astrab(date_first,dT(date_first,mode_dT=mode_dT))
    ELONG = astrabOutput[&#39;ELONG&#39;]
    ELONG[ELONG&gt;=360] -= 360.
    FAEST_first = date_first - pd.TimedeltaIndex((ELONG-45)%360/ELOINC, unit=&#39;D&#39;)

    # use the first date to create a new daterange from the correct starting time. The frequency is 29 days, 12 hours and 44 minutes, following from dood_S-dood_H
    date = pd.date_range(start=FAEST_first[0],end=date_last,freq=&#39;%iN&#39;%(FASINT*24*3600*1e9))

    # estimate all lunar phases (time and type)
    astrabOutput = astrab(date,dT(date,mode_dT=mode_dT))
    ELONG = astrabOutput[&#39;ELONG&#39;]
    ELONG[ELONG&gt;=360] -= 360.
    FATYP=(np.array(ELONG/90.).astype(int)+3)%4+1 #make sure the next phase is searched for (modulus to use &#39;FATYP-1&#39;)
    FAEST=date-pd.TimedeltaIndex((90.*FATYP-ELONG)/ELOINC, unit=&#39;D&#39;)

    # calculate exact time of phase, loop until date_last
    TIMDIF = pd.TimedeltaIndex(-dT(FAEST,mode_dT=mode_dT)+1./2880.,unit=&#39;D&#39;)
    FATIM = astrac(FAEST,dT(FAEST,mode_dT=mode_dT),FATYP+2)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataPhases = pd.DataFrame({&#39;datetime&#39;:FATIM.round(&#39;S&#39;),&#39;type&#39;:FATYP})
    dataPhases[&#39;type_str&#39;] = dataPhases[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;FQ&#39;).replace(&#39;2&#39;,&#39;FM&#39;).replace(&#39;3&#39;,&#39;LQ&#39;).replace(&#39;4&#39;,&#39;NM&#39;)
    dataPhases[&#39;datetime&#39;] = pd.to_datetime(dataPhases[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataPhases[&#39;datetime&#39;] = dataPhases[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone
    if (np.diff(dataPhases.sort_values(&#39;datetime&#39;).index)!=1).any():
        raise Exception(&#39;something went wrong with moonphases which resulted in off ordering of the dataframe, check FAEST_first degree correction&#39;)
    
    #filter datetimerange
    dataPhases_dtnaive = dataPhases[&#39;datetime&#39;].dt.tz_localize(None)
    dataPhases = dataPhases[np.logical_and(dataPhases_dtnaive&gt;=tFirst,dataPhases_dtnaive&lt;=tLast)].reset_index(drop=True)

    return dataPhases</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrog_sunriseset"><code class="name flex">
<span>def <span class="ident">astrog_sunriseset</span></span>(<span>tFirst, tLast, mode_dT='exact', tzone='UTC', lon=5.3876, lat=52.1562)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes use of the definitions dT, astrab and astrac.
Calculates sunrise and -set at requested location.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tFirst</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>Start of timeframe for output.</dd>
<dt><strong><code>tLast</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>End of timeframe for output.</dd>
<dt><strong><code>mode_dT</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method to calculate difference between universal time and terrestrial time (dT). Can be 'last' (for fortran reproduction), 'historical' or 'exact' (most accurate). The default is 'exact'.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>string/dt.timezone</code>, optional</dt>
<dd>Timezone to convert the output dataset to. The default is 'UTC'.</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Longitude, defined positive eastward. The default is -5.3876 (Amersfoort).</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Latitude, defined positive northward, cannot exceed 59 (too close to poles). The default is 52.1562 (Amersfoort).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks input times tFirst and tLast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataSun</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>datetime: time of rise or set in UTC (datetime)
type:
type
(1=sunrise, 2=sunset)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrog_sunriseset(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates sunrise and -set at requested location.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.
    lon : float, optional
        Longitude, defined positive eastward. The default is -5.3876 (Amersfoort).
    lat : float, optional
        Latitude, defined positive northward, cannot exceed 59 (too close to poles). The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataSun : pandas DataFrame
        datetime: time of rise or set in UTC (datetime)
        type:     type  (1=sunrise, 2=sunset)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst.date()-dt.timedelta(days=1)
    date_last = tLast.date()+dt.timedelta(days=1)

    # --- sunrise and -set ---
    # estimate times: starting at tFirst, 0h local solar time
    OPEST  = pd.date_range(start=date_first+dt.timedelta(days=-lon/180/24.+.25),end=date_last,freq=&#39;%iN&#39;%(24*3600*1e9)) # &#39;floor&#39; date to 00:00 +6h
    ONEST  = pd.date_range(start=date_first+dt.timedelta(days=-lon/180/24.+.75),end=date_last,freq=&#39;%iN&#39;%(24*3600*1e9)) # &#39;floor&#39; date to 00:00 +18h

    # calculate exact times
    TIMDIF = pd.TimedeltaIndex(-dT(OPEST,mode_dT=mode_dT)+1./2880.,unit=&#39;D&#39;)
    OPTIM  = astrac(OPEST,dT(OPEST,mode_dT=mode_dT),np.array( 9),lon=lon,lat=lat)+TIMDIF
    ONTIM  = astrac(ONEST,dT(ONEST,mode_dT=mode_dT),np.array(10),lon=lon,lat=lat)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataSun = pd.DataFrame({&#39;datetime&#39;:np.concatenate((OPTIM.round(&#39;S&#39;),ONTIM.round(&#39;S&#39;))),&#39;type&#39;:np.concatenate((np.full(len(OPTIM),1),np.full(len(OPTIM),2)))})
    dataSun = dataSun.sort_values(&#39;datetime&#39;).reset_index(drop=True)
    dataSun[&#39;type_str&#39;] = dataSun[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;sunrise&#39;).replace(&#39;2&#39;,&#39;sunset&#39;)
    dataSun[&#39;datetime&#39;] = pd.to_datetime(dataSun[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataSun[&#39;datetime&#39;] = dataSun[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataSun_dtnaive = dataSun[&#39;datetime&#39;].dt.tz_localize(None)
    dataSun = dataSun[np.logical_and(dataSun_dtnaive&gt;=tFirst,dataSun_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataSun</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrog_moonriseset"><code class="name flex">
<span>def <span class="ident">astrog_moonriseset</span></span>(<span>tFirst, tLast, mode_dT='exact', tzone='UTC', lon=5.3876, lat=52.1562)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes use of the definitions dT, astrab and astrac.
Calculates moonrise and -set at requested location.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tFirst</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>Start of timeframe for output.</dd>
<dt><strong><code>tLast</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>End of timeframe for output.</dd>
<dt><strong><code>mode_dT</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method to calculate difference between universal time and terrestrial time (dT). Can be 'last' (for fortran reproduction), 'historical' or 'exact' (most accurate). The default is 'exact'.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>string/dt.timezone</code>, optional</dt>
<dd>Timezone to convert the output dataset to. The default is 'UTC'.</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Longitude, defined positive eastward. The default is -5.3876 (Amersfoort).</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Latitude, defined positive northward, cannot exceed 59 (too close to poles). The default is 52.1562 (Amersfoort).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks input times tFirst and tLast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataMoon</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>datetime: time of rise or set in UTC (datetime)
type:
type
(1=moonrise, 2=moonset)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrog_moonriseset(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates moonrise and -set at requested location.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.
    lon : float, optional
        Longitude, defined positive eastward. The default is -5.3876 (Amersfoort).
    lat : float, optional
        Latitude, defined positive northward, cannot exceed 59 (too close to poles). The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataMoon : pandas DataFrame
        datetime: time of rise or set in UTC (datetime)
        type:     type  (1=moonrise, 2=moonset)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # constants
    from hatyan.hatyan_core import get_hatyan_freqs
    M2_period_hr = get_hatyan_freqs([&#39;M2&#39;]).loc[&#39;M2&#39;,&#39;period [hr]&#39;] # CULINT
    EHMINC = 346.8 # increment of ephemeris hour angle of moon (deg/day)

    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(hours=M2_period_hr+1*24)
    date_last = tLast+dt.timedelta(hours=M2_period_hr+1*24)

    # --- moonrise and -set ---
    # estimate times
    astrabOutput=astrab(date_first,dT(date_first,mode_dT=mode_dT),lon=lon,lat=lat)
    ALTMOO=astrabOutput[&#39;ALTMOO&#39;]
    EHMOON=astrabOutput[&#39;EHMOON&#39;]
    # first phenomenon is moonrise
    if ALTMOO &lt; -(0.5667+(0.08+0.2725*astrabOutput[&#39;PARLAX&#39;])/3600.):
        OPEST=pd.date_range(start=date_first+dt.timedelta(days=(270.-EHMOON[0])/EHMINC),end=date_last,freq=&#39;%iN&#39;%(M2_period_hr*2*3600*1e9))
        ONEST=OPEST+dt.timedelta(hours=M2_period_hr)
    # first phenomenon is moonset
    else:
        ONEST=pd.date_range(start=date_first+dt.timedelta(days=(90.-EHMOON[0])/EHMINC),end=date_last,freq=&#39;%iN&#39;%(M2_period_hr*2*3600*1e9))
        OPEST=ONEST+dt.timedelta(hours=M2_period_hr)

    # calculate exact times
    TIMDIF = pd.TimedeltaIndex(-dT(OPEST,mode_dT=mode_dT)+1./2880.,unit=&#39;D&#39;)
    OPTIM  = astrac(OPEST,dT(OPEST,mode_dT=mode_dT),np.array(7),lon=lon,lat=lat)+TIMDIF
    ONTIM  = astrac(ONEST,dT(ONEST,mode_dT=mode_dT),np.array(8),lon=lon,lat=lat)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataMoon = {&#39;datetime&#39;:np.concatenate((OPTIM.round(&#39;S&#39;),ONTIM.round(&#39;S&#39;))),&#39;type&#39;:np.concatenate((np.full(len(OPTIM),1),np.full(len(OPTIM),2)))}
    dataMoon = pd.DataFrame(dataMoon).sort_values(&#39;datetime&#39;).reset_index(drop=True)
    dataMoon[&#39;type_str&#39;] = dataMoon[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;moonrise&#39;).replace(&#39;2&#39;,&#39;moonset&#39;)
    dataMoon[&#39;datetime&#39;] = pd.to_datetime(dataMoon[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataMoon[&#39;datetime&#39;] = dataMoon[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataMoon_dtnaive = dataMoon[&#39;datetime&#39;].dt.tz_localize(None)
    dataMoon = dataMoon[np.logical_and(dataMoon_dtnaive&gt;=tFirst,dataMoon_dtnaive&lt;=tLast)].reset_index(drop=True)

    return dataMoon</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrog_anomalies"><code class="name flex">
<span>def <span class="ident">astrog_anomalies</span></span>(<span>tFirst, tLast, mode_dT='exact', tzone='UTC')</span>
</code></dt>
<dd>
<div class="desc"><p>Makes use of the definitions dT, astrab and astrac.
Calculates lunar anomalies. The lunar anomalies are independent of coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tFirst</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>Start of timeframe for output.</dd>
<dt><strong><code>tLast</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>End of timeframe for output.</dd>
<dt><strong><code>mode_dT</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method to calculate difference between universal time and terrestrial time (dT). Can be 'last' (for fortran reproduction), 'historical' or 'exact' (most accurate). The default is 'exact'.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>string/dt.timezone</code>, optional</dt>
<dd>Timezone to convert the output dataset to. The default is 'UTC'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks input times tFirst and tLast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataAnomaly</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>datetime:
lunar anomaly in UTC (datetime)
type:
type of anomaly (1=perigeum, 2=apogeum)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrog_anomalies(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates lunar anomalies. The lunar anomalies are independent of coordinates.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataAnomaly : pandas DataFrame
        datetime:   lunar anomaly in UTC (datetime)
        type:       type of anomaly (1=perigeum, 2=apogeum)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # constants
    ANMINC   = 13.06       # increment of anomaly of moon (deg/day)
    ANOINT   = 27.554551/2 # half of a lunar anomalistic month (days)

    # first and last datetime in calculation (add enough margin, and an extra day for timezone differences)
    date_first = tFirst-dt.timedelta(days=ANOINT+1)
    date_last = tLast+dt.timedelta(days=ANOINT+1)

    # estimate first lunar anomaly (time and type)
    astrabOutput=astrab(date_first,dT(date_first,mode_dT=mode_dT))
    DPAXDT=astrabOutput[&#39;DPAXDT&#39;]
    ANM   =astrabOutput[&#39;ANM&#39;]
    if DPAXDT&gt;0.:
        # ANOTYP=1: perigeum first
        if ANM&lt;90.:
            ANM=ANM+360.
        ANOEST = pd.date_range(start=date_first+dt.timedelta(days=(360.-ANM[0])/ANMINC),end=date_last,freq=&#39;%iN&#39;%(ANOINT*24*3600*1e9))
        ANOTYP = np.empty((len(ANOEST),)).astype(int)
        ANOTYP[::2]  = 1
        ANOTYP[1::2] = 2

    elif DPAXDT&lt;=0.:
        # ANOTYP=2: apogeum first
        if ANM&gt;270.:
            ANM=ANM-360.
        ANOEST = pd.date_range(start=date_first+dt.timedelta(days=(180.-ANM[0])/ANMINC),end=date_last,freq=&#39;%iN&#39;%(ANOINT*24*3600*1e9))
        ANOTYP = np.empty((len(ANOEST),)).astype(int)
        ANOTYP[::2]  = 2
        ANOTYP[1::2] = 1

    # calculate exact times
    TIMDIF = pd.TimedeltaIndex(-dT(ANOEST,mode_dT=mode_dT)+1./48., unit=&#39;D&#39;)
    ANOTIM = astrac(ANOEST,dT(ANOEST,mode_dT=mode_dT),ANOTYP+14)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataAnomaly = pd.DataFrame({&#39;datetime&#39;:ANOTIM.round(&#39;S&#39;),&#39;type&#39;:ANOTYP})
    dataAnomaly[&#39;type_str&#39;] = dataAnomaly[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;perigeum&#39;).replace(&#39;2&#39;,&#39;apogeum&#39;)
    dataAnomaly[&#39;datetime&#39;] = pd.to_datetime(dataAnomaly[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataAnomaly[&#39;datetime&#39;] = dataAnomaly[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataAnomaly_dtnaive = dataAnomaly[&#39;datetime&#39;].dt.tz_localize(None)
    dataAnomaly = dataAnomaly[np.logical_and(dataAnomaly_dtnaive&gt;=tFirst,dataAnomaly_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataAnomaly</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrog_seasons"><code class="name flex">
<span>def <span class="ident">astrog_seasons</span></span>(<span>tFirst, tLast, mode_dT='exact', tzone='UTC')</span>
</code></dt>
<dd>
<div class="desc"><p>Makes use of the definitions dT, astrab and astrac.
Calculates astronomical seasons. The seasons are independent of coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tFirst</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>Start of timeframe for output.</dd>
<dt><strong><code>tLast</code></strong> :&ensp;<code>datetime.datetime</code> or <code>string ("yyyymmdd")</code></dt>
<dd>End of timeframe for output.</dd>
<dt><strong><code>mode_dT</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method to calculate difference between universal time and terrestrial time (dT). Can be 'last' (for fortran reproduction), 'historical' or 'exact' (most accurate). The default is 'exact'.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>string/dt.timezone</code>, optional</dt>
<dd>Timezone to convert the output dataset to. The default is 'UTC'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks input times tFirst and tLast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataSeasons</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>datetime:
start of astronomical season in UTC (datetime)
type:
type of astronomical season (1=spring, 2=summer, 3=autumn, 4=winter)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrog_seasons(tFirst,tLast,mode_dT=&#39;exact&#39;,tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;
    Makes use of the definitions dT, astrab and astrac.
    Calculates astronomical seasons. The seasons are independent of coordinates.

    Parameters
    ----------
    tFirst : datetime.datetime or string (&#34;yyyymmdd&#34;)
        Start of timeframe for output.
    tLast : datetime.datetime or string (&#34;yyyymmdd&#34;)
        End of timeframe for output.
    mode_dT : string, optional
        Method to calculate difference between universal time and terrestrial time (dT). Can be &#39;last&#39; (for fortran reproduction), &#39;historical&#39; or &#39;exact&#39; (most accurate). The default is &#39;exact&#39;.
    tzone : string/dt.timezone, optional
        Timezone to convert the output dataset to. The default is &#39;UTC&#39;.

    Raises
    ------
    Exception
        Checks input times tFirst and tLast.

    Returns
    -------
    dataSeasons : pandas DataFrame
        datetime:   start of astronomical season in UTC (datetime)
        type:       type of astronomical season (1=spring, 2=summer, 3=autumn, 4=winter)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    # check input times (datetime or string)
    [tFirst,tLast] = convert_str2datetime(datetime_in_list=[tFirst,tLast])

    # estimate start of seasons (time and type)
    SEIEST = pd.date_range(start=dt.datetime(tFirst.year,int(np.ceil(tFirst.month/3)*3),1),end=tLast+dt.timedelta(days=1),freq=&#39;%iMS&#39;%(3))+dt.timedelta(days=20)
    SEITYP = (SEIEST.month/3).astype(int)

    # calculate exact times, loop until tLast
    TIMDIF = pd.TimedeltaIndex(-dT(SEIEST,mode_dT=mode_dT)+1./2880., unit=&#39;D&#39;) # conversion to UTC
    SEITIM = astrac(SEIEST,dT(SEIEST,mode_dT=mode_dT),SEITYP+10)+TIMDIF

    # make dataframe and crop for requested timeframe
    dataSeasons = pd.DataFrame({&#39;datetime&#39;:SEITIM.round(&#39;S&#39;),&#39;type&#39;:SEITYP})
    dataSeasons[&#39;type_str&#39;] = dataSeasons[&#39;type&#39;].astype(str).replace(&#39;1&#39;,&#39;spring&#39;).replace(&#39;2&#39;,&#39;summer&#39;).replace(&#39;3&#39;,&#39;autumn&#39;).replace(&#39;4&#39;,&#39;winter&#39;)
    dataSeasons[&#39;datetime&#39;] = pd.to_datetime(dataSeasons[&#39;datetime&#39;]).dt.tz_localize(&#39;UTC&#39;,ambiguous=False,nonexistent=&#39;shift_forward&#39;) # set timezone (UTC)
    dataSeasons[&#39;datetime&#39;] = dataSeasons[&#39;datetime&#39;].dt.tz_convert(tzone) #convert timezone to tzone

    #filter datetimerange
    dataSeasons_dtnaive = dataSeasons[&#39;datetime&#39;].dt.tz_localize(None)
    dataSeasons = dataSeasons[np.logical_and(dataSeasons_dtnaive&gt;=tFirst,dataSeasons_dtnaive&lt;=tLast)].reset_index(drop=True)
    
    return dataSeasons</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrab"><code class="name flex">
<span>def <span class="ident">astrab</span></span>(<span>date, dT_TT, lon=5.3876, lat=52.1562)</span>
</code></dt>
<dd>
<div class="desc"><p>Python version of astrab.f in FORTRAN 77
Calculates 18 astronomical parameters at requested time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>date</code></strong> :&ensp;<code>datetime.datetime</code> or <code>pandas.DatetimeIndex</code></dt>
<dd>Requested time for calculation.</dd>
<dt><strong><code>dT_TT</code></strong> :&ensp;<code>float</code></dt>
<dd>Difference between terrestrial and universal time in days.</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Longitude for altitudes, defined positive eastward. The default is 5.3876 (Amersfoort).</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Latitude for altitudes, defined positive northward. The default is 52.1562 (Amersfoort).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks if input is valid.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>astrabOutput</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>18 astronomical variables:
EHMOON, lunar ephemeris hour angle (degrees between +90 and +450)
DECMOO, lunar declination (degrees)
PARLAX, lunar horizontal parallax (arcseconds)
DPAXDT, time derivative of parallax (arcseconds/day)
ALTMOO, lunar altitude (degrees, negative below horizon)
ELONG,
ecliptic elongation moon-sun (degrees, between +45 and +405)
ALTSUN, solar altitude (degrees, negative under horizon)
LONSUN, solar longitude (degrees, between 45 and 405)
EQELON, equatorial elongaton moon-sun (degrees, between 0 and 360)
DECSUN, solar declination (degrees)
DISSUN, relative distance earth-sun (astronomical units)
EHARI,
ephemeris hour angle vernal equinox (degrees, between 0 and 360)
RASUN,
solar right ascension (degrees, between 0 and 360)
EHSUN,
solar ephemeris hour angle (degrees, between 0 and 360)
LONMOO, lunar longitude (degrees, between 0 and 360)
LATMOO, lunar latitude (degrees)
RAMOON, lunar right ascension (degrees, between 0 and 360)
ANM,
mean lunar anomaly (degrees, between 0 and 360)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrab(date,dT_TT,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Python version of astrab.f in FORTRAN 77
    Calculates 18 astronomical parameters at requested time.

    Parameters
    ----------
    date : datetime.datetime or pandas.DatetimeIndex
        Requested time for calculation.
    dT_TT : float
        Difference between terrestrial and universal time in days.
    lon : float, optional
        Longitude for altitudes, defined positive eastward. The default is 5.3876 (Amersfoort).
    lat : float, optional
        Latitude for altitudes, defined positive northward. The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks if input is valid.

    Returns
    -------
    astrabOutput : dictionary
        18 astronomical variables:
            EHMOON, lunar ephemeris hour angle (degrees between +90 and +450)
            DECMOO, lunar declination (degrees)
            PARLAX, lunar horizontal parallax (arcseconds)
            DPAXDT, time derivative of parallax (arcseconds/day)
            ALTMOO, lunar altitude (degrees, negative below horizon)
            ELONG,  ecliptic elongation moon-sun (degrees, between +45 and +405)
            ALTSUN, solar altitude (degrees, negative under horizon)
            LONSUN, solar longitude (degrees, between 45 and 405)
            EQELON, equatorial elongaton moon-sun (degrees, between 0 and 360)
            DECSUN, solar declination (degrees)
            DISSUN, relative distance earth-sun (astronomical units)
            EHARI,  ephemeris hour angle vernal equinox (degrees, between 0 and 360)
            RASUN,  solar right ascension (degrees, between 0 and 360)
            EHSUN,  solar ephemeris hour angle (degrees, between 0 and 360)
            LONMOO, lunar longitude (degrees, between 0 and 360)
            LATMOO, lunar latitude (degrees)
            RAMOON, lunar right ascension (degrees, between 0 and 360)
            ANM,    mean lunar anomaly (degrees, between 0 and 360)

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt


    # check input
    if isinstance(date, pd.DatetimeIndex):
        pass
    elif isinstance(date, dt.datetime):
        date = pd.DatetimeIndex([date])
    else:
        raise Exception(&#39;Input variable date should be datetime or pd.DateTimeIndex&#39;)

    if np.abs(lon)&gt;180:
        raise Exception(&#39;Input variable longitude larger than 180deg&#39;)
    if np.abs(lat)&gt;90:
        raise Exception(&#39;Input variable latitude larger than 90deg&#39;)

    # constants - general
    EPOCH  = dt.datetime(1899, 12, 31, 12, 0, 0) # 1900.0 # -12h shift because julian date 0 is at noon?
    # The average orbital elements of the celestial bodies are calculated for the epoch 1900.0.
    # The values are corrected for the year 1990. Intitial values are from the vernal equinox.

    # constants - sun
    LABOS  = 4.8816237     # longitude sun (rad)
    NSUN   = 0.01720279153 # increment longitude sun (rad/day)
    PEROS  = 4.9082230     # longitude perigeum sun (rad)
    BETSUN = 8.2188819E-7  # increment longitude perigeum sun (rad/day)

    # constants - moon
    LABOM  = 4.7199860     # longitude moon (rad)
    NMOON  = 0.2299715020  # increment longitude moon (rad/day)
    PEROM  = 5.8352992     # longitude perigeum moon (rad)
    BETMOO = 0.0019443591  # increment longitude perigeum moon (rad/day)
    NODOM  = 4.523572      # longitude lunar orbital node lunar (rad)
    GAMMOO =-9.2421851E-4  # increment longitude lunar orbital node lunar (rad/day)
    INMOON = 0.089804108   # inclination lunar orbit (rad)
    PARMEA = 3422.608      # mean horizontal lunar parallax (arcseconds)

    # constants - planets
    VENTZE = 1.10079       # elongation Venus-Earth (rad)
    VENTIN = 0.010760328   # increment elongation Venus-Earth (rad/day)
    TJUPZE = 3.86848       # elongation Earth-Jupiter (rad)
    TJUPIN = 0.015751909   # increment elongation Earth-Jupiter (rad/day)
    TMARZE = 2.89636       # elongation Earth-Mars (rad)
    TMARIN = 0.008056024   # increment elongation Earth-Mars (rad/day)
    TSATZE = 3.37079       # elongation Earth-Saturnus (rad)
    TSATIN = 0.016618143   # increment elongation Earth-Saturnus (rad/day)

    # constants - ecliptic
    OBZERO = 0.40931977    # inclination of ecliptic (rad)
    OBINC  =-6.21937E-9    # increment inclination of ecliptic (rad/day)

    # constants - vernal equinox
    ARZERO = 4.881523      # ephemeris hour angle of vernal equinox (rad)
    NARIES = 6.30038809878 # increment ephemeris hour angle of vernal equinox (rad/day)

    # constants - lunar orbital disturbances
    # selected from Brown&#39;s Tables of the Motion of the Moon (1909)
    # in longitude
    distP = {&#39;col1&#39;:[        0,            0,            1,            1,        1,        1,            1,            0,            0,            0,            0,            0,            2,            2,            2,            2,            1,            1,            1,            1,            1,            1,            1,            0,            0,            0,            0,            0,            1,            1,            1,            0,            3,            3,            3,            3,            2,            2,            2,            2,            2,            2,            1,            1,            1,            1,            1,            1,            1,            1,            1,            0,            0,            2,            2,            1,            1,            4,            4,            2,            2],
             &#39;col2&#39;:[        0,            0,            0,            0,        0,        0,            0,            1,            1,            1,            1,            0,            0,            0,            0,            0,            1,            1,            1,            1,           -1,           -1,           -1,            2,            2,            0,            0,            0,            0,            0,            0,            1,            0,            0,            0,            0,            1,            1,            1,           -1,           -1,           -1,            2,            2,           -2,           -2,            0,            0,            0,            0,            0,            1,            1,            0,            0,            1,           -1,            0,            0,            0,            0],
             &#39;col3&#39;:[        0,            0,            0,            0,        0,        0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            2,            2,            2,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            2,            2,           -2,           -2,           -2,            2,           -2,            0,            0,            0,            0,            0,            0,            2,           -2],
             &#39;col4&#39;:[        4,            2,            4,            2,        0,       -2,           -4,            2,            0,           -2,           -4,            1,            2,            0,           -2,           -4,            2,            0,           -2,           -4,            2,            0,           -2,            0,           -2,            2,            0,           -2,            1,           -1,           -3,            1,            2,            0,           -2,           -4,            0,           -2,           -4,            2,            0,           -2,            0,           -2,            0,           -2,            2,            0,            2,            0,           -2,           -2,            2,           -1,           -3,            1,           -1,            0,           -2,            0,            0],
             &#39;col5&#39;:[   13.902,     2369.902,        1.979,      191.953,22639.500,-4586.426,      -38.428,      -24.420,     -666.608,     -164.773,       -1.877,     -125.154,       14.387,      769.016,     -211.656,      -30.773,       -2.921,     -109.420,     -205.499,       -4.391,       14.577,      147.361,       28.475,       -7.486,       -8.096,       -5.741,     -411.608,      -55.173,       -8.466,       18.609,        3.215,       18.023,        1.060,       36.124,      -13.193,       -1.187,       -7.649,       -8.627,       -2.740,        1.181,        9.703,       -2.494,       -1.167,       -7.412,        2.580,        2.533,        -.992,      -45.099,       -6.382,       39.532,        9.366,       -2.152,       -1.440,        1.750,        1.225,        1.267,       -1.089,        1.938,        -.952,       -3.996,       -1.298],}
    distP = pd.DataFrame(distP)
    # in latitude
    distC = {&#39;col1&#39;:[     0,     2,     3,     0,     0,     1,     1,    -1,    -1],
             &#39;col2&#39;:[     0,     0,     0,     1,     2,     1,     1,     1,     1],
             &#39;col3&#39;:[     0,     0,     0,     0,     0,     0,     0,     0,     0],
             &#39;col4&#39;:[     1,    -2,     0,     0,    -2,     2,    -2,     0,    -2],
             &#39;col5&#39;:[ -.725, 5.679,-1.300,-1.302, -.740,  .787, 2.056,  .679,-1.540]}
    distC = pd.DataFrame(distC)
    distS = {&#39;col1&#39;:[       0,       0,       0,       1,       1,       1,       1,       1,       1,       2,       2,       2,       2,       3,       3,       0,       0,       0,       0,       0,       0,       1,       1,       1,       1,      -1,      -1,      -1,       2,       2,       2,       1,       0,       1,      -1],
             &#39;col2&#39;:[       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       1,       1,       1,       1,       1,       2,       1,       1,       1,       1,       1,       1,       1,       1,       1,      -1,       2,       0,       0,       0],
             &#39;col3&#39;:[       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       0,       2,       2,       2],
             &#39;col4&#39;:[       1,       2,       4,       4,       2,       0,      -2,      -3,      -4,       2,       0,      -2,      -4,       0,      -2,       2,       1,       0,      -2,      -4,      -2,       2,       0,      -2,      -4,       2,       0,      -2,       0,      -2,       0,      -2,      -2,      -2,       0],
             &#39;col5&#39;:[ -112.79, 2373.36,   14.06,    6.98,  192.72,22609.07,-4578.13,    5.44,  -38.64,   14.78,  767.96, -152.53,  -34.07,   50.64,  -16.40,  -25.10,   17.93, -126.98, -165.06,   -6.46,  -16.35,  -11.75, -115.18, -182.36,   -9.66,  -23.59, -138.76,  -31.70,  -10.56,   -7.59,   11.67,   -6.12,  -52.14,   -9.52,  -85.13]}
    distS = pd.DataFrame(distS)
    distN = {&#39;col1&#39;:[       0,       0,       1,       1,      -1,      -1,      -2,      -2,       0,       0],
             &#39;col2&#39;:[       0,       0,       0,       0,       0,       0,       0,       0,       1,      -1],
             &#39;col3&#39;:[       1,       1,       1,       1,       1,       1,       1,       1,       1,       1],
             &#39;col4&#39;:[      -2,      -4,      -2,      -4,       0,      -2,       0,      -2,      -2,      -2],
             &#39;col5&#39;:[-526.069,  -3.352,  44.297,  -6.000,  20.599, -30.598, -24.649,  -2.000, -22.571,  10.985]}
    distN = pd.DataFrame(distN)
    # in parallax
    distR = {&#39;col1&#39;:[        0,        0,        1,        1,        1,        1,        0,        0,        0,        0,        2,        2,        2,        2,        1,        1,        1,        1,        1,        0,        1,        0,        3,        3,        2,        2,        1],
             &#39;col2&#39;:[        0,        0,        0,        0,        0,        0,        1,        1,        1,        0,        0,        0,        0,        0,        1,        1,       -1,       -1,       -1,        0,        0,        1,        0,        0,        1,       -1,        0],
             &#39;col3&#39;:[        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0,        2,        0,        0,        0,        0,        0,        0,       -2],
             &#39;col4&#39;:[        4,        2,        2,        0,       -2,       -4,        2,        0,       -2,        1,        2,        0,       -2,       -4,        0,       -2,        2,        0,       -2,       -2,        1,        1,        0,       -2,        0,        0,        0],
             &#39;col5&#39;:[    .2607,  28.2333,   3.0861, 186.5398,  34.3117,    .6008,   -.2993,   -.3988,   1.9135,   -.9781,    .2833,  10.1657,   -.3039,    .3722,   -.9469,   1.4404,    .2297,   1.1502,   -.2252,   -.1052,   -.1093,    .1494,    .6215,   -.1187,   -.1038,    .1268,   -.7136]}
    distR = pd.DataFrame(distR)

    # process input data
    TIME  = np.array((date-EPOCH).total_seconds()/86400) # days since 1900
    if (TIME&lt;0).any() or (TIME&gt;70000).any():
        raise Exception(&#39;Requested time out of range (1900-2091)&#39;)
    RLONG=-np.deg2rad(lon)
    RLATI= np.deg2rad(lat)

    # mean orbital elements
    # of sun, including additive correction
    LABSUN=(LABOS -np.deg2rad(6.22/3600) +NSUN*TIME) % (2*np.pi)
    PERSUN=PEROS+BETSUN*TIME
    # of moon
    LABMOO=(LABOM+NMOON *TIME) % (2*np.pi)
    PERMOO=(PEROM+BETMOO*TIME) % (2*np.pi)
    NODMOO=NODOM+GAMMOO*TIME
    # additive corrections for moon
    LABMOO=LABMOO+np.deg2rad(( 0.79 +14.27 *np.sin(6.0486+6.34913E-5*TIME)+7.261*np.sin(NODMOO))/3600)
    PERMOO=PERMOO+np.deg2rad((-1.966- 2.076*np.sin(NODMOO))/3600)
    NODMOO=NODMOO+np.deg2rad(( 0.59 +95.96 *np.sin(NODMOO)+15.58*np.sin(NODMOO+4.764400))/3600)
    CINMOO=np.deg2rad((-8.636*np.cos(NODMOO)-1.396*np.cos(NODMOO+4.764400))/3600)

    # mean heliocentric elongation Venus-Earth, Earth-Jupiter, Earth-Mars and Earth-Saturnus
    VENTER=VENTZE+TIME*VENTIN
    TERJUP=TJUPZE+TIME*TJUPIN
    TERMAR=TMARZE+TIME*TMARIN
    TERSAT=TSATZE+TIME*TSATIN

    # Nutation in longitude
    CNULON=-17.248*np.sin(NODMOO)-1.273*np.sin(2.*LABSUN)
    # Nutation in inclination of ecliptic
    CNUTOB=  9.21 *np.cos(NODMOO)+0.55 *np.cos(2.*LABSUN)

    # inclination of ecliptic, sine and cosine of inclination
    OBLIQ=OBZERO+TIME*OBINC+np.deg2rad(CNUTOB/3600)
    SINOB=np.sin(OBLIQ)
    COSOB=np.cos(OBLIQ)

    # parameters of sun and moon for disturbance equations
    ANM=LABMOO-PERMOO # output value 18: mean lunar anomaly (rad)
    ANS=LABSUN-PERSUN
    FNO=LABMOO-NODMOO
    ELO=LABMOO-LABSUN
    DAM=NMOON-BETMOO
    DAS=NSUN-BETSUN
    DFN=NMOON-GAMMOO
    DEL=NMOON-NSUN

    # disturbance equations
    # disturbances in longitude sun
    # equation of center
    CENTR=(6910.10 -17.33*TIME/36525)*np.sin(ANS)+72.01*np.sin(2.*ANS) + 1.05*np.sin(3.*ANS)
    # planetary disturbances
    PLANET= ( 4.838*np.cos(   VENTER       +1.5708)
             +5.526*np.cos(2.*VENTER       +1.5723)
             +0.666*np.cos(3.*VENTER       +4.7195)
             +2.497*np.cos(2.*VENTER   -ANS+4.4986)
             +1.559*np.cos(3.*VENTER   -ANS+1.3607)
             +1.024*np.cos(3.*VENTER-2.*ANS+0.8875)
             +7.208*np.cos(   TERJUP       +1.5898)
             +2.731*np.cos(2.*TERJUP       +4.7168)
             +2.600*np.cos(   TERJUP   -ANS+3.0503)
             +1.610*np.cos(2.*TERJUP   -ANS+5.1068)
             +0.556*np.cos(3.*TERJUP   -ANS+3.0946)
             +2.043*np.cos(2.*TERMAR       +1.5660)
             +1.770*np.cos(2.*TERMAR   -ANS+5.3454)
             +0.585*np.cos(4.*TERMAR-2.*ANS+3.2432)
             +0.500*np.cos(4.*TERMAR   -ANS+5.5317)
             +0.425*np.cos(3.*TERMAR   -ANS+5.5449)
             +0.419*np.cos(   TERSAT       +1.5767)
             +0.320*np.cos(   TERSAT   -ANS+4.5242))
    # geometric disturbance by the moon
    GEOM=6.454*np.sin(ELO)-0.424*np.sin(ELO-ANM)
    # aberration (correction for optical path)
    ABER=-(20.496+.344*np.cos(ANS))
    # longitude sun with all disturbances
    LONSUN=LABSUN+np.deg2rad((CENTR+PLANET+GEOM+CNULON+ABER)/3600) # output value 8: solar longitude (rad)
    # relative distance from sun
    DISSUN=1.000140 - 0.016712*np.cos(ANS) - 0.000140*np.cos(2.*ANS) # output value 11: relative distance earth-sun (astronomical units)
    # longitude moon with all disturbances
    CLONM=0
    for i in range(0,len(distP)):
        CLONM=CLONM+np.sin(distP[&#39;col1&#39;][i]*ANM+distP[&#39;col2&#39;][i]*ANS+distP[&#39;col3&#39;][i]*FNO+distP[&#39;col4&#39;][i]*ELO) * distP[&#39;col5&#39;][i]
    LONMOO=LABMOO+np.deg2rad((CNULON+CLONM)/3600) # output value 15: lunar longitude (rad)
    # latitude moon with all disturbances
    CLM=0
    for i in range(0,len(distC)):
        CLM=CLM+np.cos(distC[&#39;col1&#39;][i]*ANM+distC[&#39;col2&#39;][i]*ANS+distC[&#39;col3&#39;][i]*FNO+distC[&#39;col4&#39;][i]*ELO) * distC[&#39;col5&#39;][i]
    SLM=0
    for i in range(0,len(distS)):
        SLM=SLM+np.sin(distS[&#39;col1&#39;][i]*ANM+distS[&#39;col2&#39;][i]*ANS+distS[&#39;col3&#39;][i]*FNO+distS[&#39;col4&#39;][i]*ELO) * distS[&#39;col5&#39;][i]
    SF=FNO+np.deg2rad(SLM/3600)
    NLM=0
    for i in range(0,len(distN)):
        NLM=NLM+np.sin(distN[&#39;col1&#39;][i]*ANM+distN[&#39;col2&#39;][i]*ANS+distN[&#39;col3&#39;][i]*FNO+distN[&#39;col4&#39;][i]*ELO) * distN[&#39;col5&#39;][i]
    LATMOO=((18519.7+CLM)*np.sin(SF) - 6.241*np.sin(3.*SF) + NLM)*np.deg2rad((1.+CINMOO/INMOON)/3600) # output value 16: lunar latitude (rad)

    # lunar parallax
    PARLAX=PARMEA # output value 3: lunar horizontal parallax (arcseconds)
    for i in range(0,len(distR)):
        PARLAX=PARLAX+np.cos(distR[&#39;col1&#39;][i]*ANM+distR[&#39;col2&#39;][i]*ANS+distR[&#39;col3&#39;][i]*FNO+distR[&#39;col4&#39;][i]*ELO) * distR[&#39;col5&#39;][i]
    # derrivative of lunar parallax
    DPAXDT=0. # output value 4: time derivative of parallax (arcseconds/day)
    for i in range(0,len(distR)):
        DPAXDT=(DPAXDT-np.sin(distR[&#39;col1&#39;][i]*ANM+distR[&#39;col2&#39;][i]*ANS+distR[&#39;col3&#39;][i]*FNO+distR[&#39;col4&#39;][i]*ELO) *
                (distR[&#39;col1&#39;][i]*DAM+distR[&#39;col2&#39;][i]*DAS+distR[&#39;col3&#39;][i]*DFN+distR[&#39;col4&#39;][i]*DEL) * distR[&#39;col5&#39;][i])

    # ecliptic elongation moon-sun
    ELONG=LONMOO-LONSUN # output value 6: ecliptic elongation moon-sun (rad)

    # transformation to equatorial coordinates
    TEMP1=np.sin(LONSUN)
    TEMP2=np.cos(LONSUN)
    RASUN=np.arctan2(TEMP1*COSOB,TEMP2)                          # output value 13: solar right ascension (rad)
    TEMP3=TEMP1*SINOB
    DECSUN=np.arcsin(TEMP3)                                      # output value 10: solar declination (rad)
    TEMP4=np.sin(LONMOO)
    TEMP5=np.cos(LONMOO)
    TEMP6=np.sin(LATMOO)
    TEMP7=np.cos(LATMOO)
    RAMOON=np.arctan2(TEMP7*TEMP4*COSOB-TEMP6*SINOB,TEMP7*TEMP5) # output value 17: lunar right ascension (rad)
    TEMP8=TEMP7*TEMP4*SINOB+TEMP6*COSOB
    DECMOO=np.arcsin(TEMP8)                                      # output value 2: lunar declination (rad)
    EQELON=RAMOON-RASUN                                          # output value 9: equatorial elongaton moon-sun (rad)

    # uurhoeken
    EHARI  =(ARZERO+NARIES*TIME+COSOB*np.deg2rad(CNULON/3600)) % (2*np.pi)    # output value 12: ephemeris hour angle of vernal equinox (rad)
    LHARI  =EHARI-dT_TT*NARIES-RLONG                             # local hour angle of vernal equinox (rad)
    EHSUN  =EHARI-RASUN                                          # output value 14: solar ephemeris hour angle (rad)
    EHMOON =EHARI-RAMOON                                         # output value  1: lunar ephemeris hour angle (rad)
    LHSUN  =LHARI-RASUN                                          # local solar hour angle (rad)
    LHMOON =LHARI-RAMOON                                         # local lunar hour angle (rad)

    # transformation to local coordinates
    ARGUM=TEMP3*np.sin(RLATI)+np.cos(DECSUN)*np.cos(RLATI)*np.cos(LHSUN)
    ALTSUN=np.nan_to_num(np.arcsin(ARGUM),nan=np.copysign(np.pi/2,ARGUM))  # output value 7: solar altitude (rad). Makes use of np.nan_to_num, filling in condition from if-statement
    ARGUM=TEMP8*np.sin(RLATI)+np.cos(DECMOO)*np.cos(RLATI)*np.cos(LHMOON)
    ALTMOO=np.arcsin(ARGUM)
    ALTMOO=np.nan_to_num(ALTMOO-np.cos(ALTMOO)*np.deg2rad(PARLAX/3600),nan=np.copysign(np.pi/2,ARGUM)) # output value 5: lunar altitude (rad). Makes use of np.nan_to_num, filling in condition from if-statement

    # summarize in dataframe and convert output to degrees
    astrabOutput = {&#39;EHMOON&#39;:((np.rad2deg(EHMOON)+ 720.-90.) % 360.)+90.,
                    &#39;DECMOO&#39;:  np.rad2deg(DECMOO),
                    &#39;PARLAX&#39;:  PARLAX,
                    &#39;DPAXDT&#39;:  DPAXDT,
                    &#39;ALTMOO&#39;:  np.rad2deg(ALTMOO),
                    &#39;ELONG&#39; :((np.rad2deg(ELONG )+1080.-45.) % 360.)+45.,
                    &#39;ALTSUN&#39;:  np.rad2deg(ALTSUN),
                    &#39;LONSUN&#39;:((np.rad2deg(LONSUN)+ 720.-45.) % 360.)+45.,
                    &#39;EQELON&#39;: (np.rad2deg(EQELON)+ 720.)     % 360.,
                    &#39;DECSUN&#39;:  np.rad2deg(DECSUN),
                    &#39;DISSUN&#39;:  DISSUN,
                    &#39;EHARI&#39; :  EHARI,
                    &#39;RASUN&#39; : (np.rad2deg(RASUN )+ 360.)     % 360.,
                    &#39;EHSUN&#39; : (np.rad2deg(EHSUN )+ 720.)     % 360.,
                    &#39;LONMOO&#39;: (np.rad2deg(LONMOO)+ 720.)     % 360.,
                    &#39;LATMOO&#39;:  np.rad2deg(LATMOO),
                    &#39;RAMOON&#39;: (np.rad2deg(RAMOON)+ 360.)     % 360.,
                    &#39;ANM&#39;   : (np.rad2deg(ANM)   + 720.)     % 360.}

    return astrabOutput</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.astrac"><code class="name flex">
<span>def <span class="ident">astrac</span></span>(<span>timeEst, dT_TT, mode, lon=5.3876, lat=52.1562)</span>
</code></dt>
<dd>
<div class="desc"><p>Python version of astrac.f in FORTRAN 77.
Calculates exact time of requested astronomical phenomenon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeEst</code></strong> :&ensp;<code>datetime.datetime</code> or <code>pandas.DatetimeIndex</code></dt>
<dd>Estimated time for iteration.</dd>
<dt><strong><code>dT_TT</code></strong> :&ensp;<code>float</code></dt>
<dd>Difference between terrestrial and universal time in days.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>numpy.array</code> of <code>integer(s)</code></dt>
<dd>Requested phenomenon:
1:
lunar lower culmination (EHMOON=180 deg.)
2:
lunar upper culmination (EHMOON=360 deg.)
3:
lunar first quarter (ELONG=90 deg.)
4:
full moon (ELONG=180 deg.)
5:
lunar last quarter (ELONG=270 deg.)
6:
new moon (ELONG=360 deg.)
7:
moonrise (ALTMOO=-34 BOOGMIN-SEMIDIAM., ascending)
8:
moonset (ALTMOO=-34 BOOGMIN-SEMIDIAM., descending)
9:
sunrise (ALTSUN=-50 arcseconds, ascending)
10: sunset (ALTSUN=-50 arcseconds, descending)
11: vernal equinox (LONSUN=360 deg.)
12: summer solstice (LONSUN=90 deg.)
13: autumnal equinox (LONSUN=180 deg.)
14: winter solstice (LONSUN=270 deg.)
15: perigeum (DPAXDT=0, descending)
16: apogeum (DPAXDT=0, ascending)</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Longitude for rise and set, defined positive eastward. The default is 5.3876 (Amersfoort).</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Latitude for rise and set, defined positive northward, cannot exceed 59 for modes 7 to 10 (too close to poles). The default is 52.1562 (Amersfoort).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Checks if latitude is not too close to poles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>TIMOUT</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Exact time after iteration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astrac(timeEst,dT_TT,mode,lon=5.3876,lat=52.1562):
    &#34;&#34;&#34;
    Python version of astrac.f in FORTRAN 77.
    Calculates exact time of requested astronomical phenomenon.

    Parameters
    ----------
    timeEst : datetime.datetime or pandas.DatetimeIndex
        Estimated time for iteration.
    dT_TT : float
        Difference between terrestrial and universal time in days.
    mode : numpy.array of integer(s)
        Requested phenomenon:
            1:  lunar lower culmination (EHMOON=180 deg.)
            2:  lunar upper culmination (EHMOON=360 deg.)
            3:  lunar first quarter (ELONG=90 deg.)
            4:  full moon (ELONG=180 deg.)
            5:  lunar last quarter (ELONG=270 deg.)
            6:  new moon (ELONG=360 deg.)
            7:  moonrise (ALTMOO=-34 BOOGMIN-SEMIDIAM., ascending)
            8:  moonset (ALTMOO=-34 BOOGMIN-SEMIDIAM., descending)
            9:  sunrise (ALTSUN=-50 arcseconds, ascending)
            10: sunset (ALTSUN=-50 arcseconds, descending)
            11: vernal equinox (LONSUN=360 deg.)
            12: summer solstice (LONSUN=90 deg.)
            13: autumnal equinox (LONSUN=180 deg.)
            14: winter solstice (LONSUN=270 deg.)
            15: perigeum (DPAXDT=0, descending)
            16: apogeum (DPAXDT=0, ascending)
    lon : float, optional
        Longitude for rise and set, defined positive eastward. The default is 5.3876 (Amersfoort).
    lat : float, optional
        Latitude for rise and set, defined positive northward, cannot exceed 59 for modes 7 to 10 (too close to poles). The default is 52.1562 (Amersfoort).

    Raises
    ------
    Exception
        Checks if latitude is not too close to poles.

    Returns
    -------
    TIMOUT : datetime
        Exact time after iteration.

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    if isinstance(timeEst, pd.DatetimeIndex):
        pass
    elif isinstance(timeEst, dt.datetime):
        timeEst = pd.DatetimeIndex([timeEst])
    else:
        raise Exception(&#39;Input variable date should be datetime or pd.DateTimeIndex&#39;)

    # constants - iteration targets
    ANGLE  = np.array([180.   , 360.   , 90.    , 180.    ,   270.  , 360.    ,   -.5667,    -.5667,     -.8333,     -.8333, 360.     , 90.     , 180.     , 270.     ,   0.   ,  0.   ])
    CRITER = np.array([  0.001,   0.001,  0.0001,   0.0001,   0.0001,   0.0001,   0.0002,    0.0002,     0.0002,     0.0002,   0.00001,  0.00001,   0.00001,   0.00001,   0.002,  0.002])
    RAT    = np.array([346.8  , 346.8  , 12.2   ,  12.2   ,    12.2 ,  12.2   , 346.8   , -346.8   ,   360.    ,  -360.    ,   1.     ,  1.     ,   1.     ,   1.     , -10.08 , 10.08 ])
    ANG =ANGLE [mode-1] # required value after iteration
    CRIT=CRITER[mode-1] # allowed difference between ANG and iteration result
    RATE=RAT   [mode-1] # estimated change per day for iteration
    if (mode&gt;=7).any() and (mode&lt;=10).any(): # correct RATE in case of rise and set for latitude
        if np.abs(lat)&gt;59:
            raise Exception(&#39;Latitude to close to poles (&gt;59deg), cannot take polar days and nights into account&#39;)
        RATE=RATE*np.cos(np.deg2rad(lat))

    # define astrab output parameter corresponding to requested mode
    if   ((mode== 1) | (mode== 2)).all():
        IPAR = &#39;EHMOON&#39;
    elif ((mode&gt;= 3) &amp; (mode&lt;= 6)).all():
        IPAR = &#39;ELONG&#39;
    elif ((mode&gt;= 7) &amp; (mode&lt;= 8)).all():
        IPAR = &#39;ALTMOO&#39;
    elif ((mode&gt;= 9) &amp; (mode&lt;=10)).all():
        IPAR = &#39;ALTSUN&#39;
    elif ((mode&gt;=11) &amp; (mode&lt;=14)).all():
        IPAR = &#39;LONSUN&#39;
    elif ((mode&gt;=15) &amp; (mode&lt;=16)).all():
        IPAR = &#39;DPAXDT&#39;
    else:
        raise Exception(&#39;Requested mode (%s) not recognized&#39; % mode)

    # calculate value at start of iteration
    TNEW=timeEst
    astrabOutput = astrab(TNEW,dT_TT,lon=lon,lat=lat)
    PNEW=astrabOutput[IPAR]

    # iterate until criterium is reached or max 20 times
    ITER=1
    while (abs(ANG-PNEW) &gt; CRIT).any():# and ITER &lt;=20:
        TOLD=TNEW
        POLD=PNEW
        if (mode==7).any() or (mode==8).any(): # correction for semidiameter moon
            ANG=ANGLE[mode-1]-(0.08+0.2725*astrabOutput[&#39;PARLAX&#39;])/3600.
        TNEW=TOLD+pd.TimedeltaIndex(np.nan_to_num((ANG-POLD)/RATE),unit=&#39;D&#39;) #nan_to_num to make sure no NaT output in next iteration
        astrabOutput = astrab(TNEW,dT_TT,lon=lon,lat=lat)
        ITER=ITER+1
        PNEW=astrabOutput[IPAR]
        RATE=np.array((PNEW-POLD)/((TNEW-TOLD).total_seconds()/86400))
        if ITER&gt;20:
            raise Exception(&#39;Stopped after %s iterations, datetime=%s&#39; %(ITER-1,TNEW))
    TIMOUT=TNEW#.round(&#39;S&#39;) # rounding everything to seconds reduces the accuracy of the reporduction of FORTRAN culmination times

    return TIMOUT</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.dT"><code class="name flex">
<span>def <span class="ident">dT</span></span>(<span>dateIn, mode_dT='exact')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates difference between terrestrial time and universal time.
Current hard-coded values valid until 2023, update arrays afterwards.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dateIn</code></strong> :&ensp;<code>datetime.datetime</code> or <code>pandas.DatetimeIndex</code></dt>
<dd>Date for correction. Definition makes use of provided year.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>'last': using the last hard-coded value (as last FORTRAN version)
'historical': using all (previous) hard-coded values (historical FORTRAN versions)
'exact' (default): determine dT based on number of leap seconds (follows international definition)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Warning</code></dt>
<dd>Checks if hard-coded values can still be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dT_TT</code></strong> :&ensp;<code>float</code></dt>
<dd>Difference dT between terrestrial time (TT) and universal time (UT1) in seconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dT(dateIn,mode_dT=&#39;exact&#39;):
    &#34;&#34;&#34;
    Calculates difference between terrestrial time and universal time.
    Current hard-coded values valid until 2023, update arrays afterwards.

    Parameters
    ----------
    dateIn : datetime.datetime or pandas.DatetimeIndex
        Date for correction. Definition makes use of provided year.
    mode : string, optional
        &#39;last&#39;: using the last hard-coded value (as last FORTRAN version)
        &#39;historical&#39;: using all (previous) hard-coded values (historical FORTRAN versions)
        &#39;exact&#39; (default): determine dT based on number of leap seconds (follows international definition)

    Raises
    ------
    Warning
        Checks if hard-coded values can still be used.

    Returns
    -------
    dT_TT : float
        Difference dT between terrestrial time (TT) and universal time (UT1) in seconds

    &#34;&#34;&#34;
    import pandas as pd
    import numpy as np
    import datetime as dt

    if isinstance(dateIn, pd.DatetimeIndex):
        pass
    elif isinstance(dateIn, dt.datetime):
        dateIn = pd.DatetimeIndex([dateIn])
    else:
        raise Exception(&#39;Input variable date should be datetime or pd.DateTimeIndex&#39;)

    if mode_dT==&#39;last&#39; or mode_dT==&#39;historical&#39;: # use approximation of dT based on hard-coded values
        # historical hard-coded values (taken from FORTRAN comments) from Astronomical Almanac - Reduction of time scales
        dT_TTyear     = [ 1980,  1993,  2002,  2012 ] # year of used dT_TTval value
        dT_TTval      = [50.97, 59.35, 64.90, 67.184] # difference between TT and UT1 (32.184s + leap seconds)
        dT_TTinc      = [0.998,  0.70,  0.42,  0.676] # yearly increment of dT curve: (dT_last-dT_5yBefore)/5
        if (dateIn.year&gt;dT_TTyear[-1]+11).any(): # check if the last hard-coded value can still be used
            print(&#39;WARNING: update hard-coded arrays in definition dT to continue using astrog for modes &#34;last&#34; and &#34;historical&#34;&#39;)
        #SCL: changed way to set ind to work with pandas DatetimeIndex
        ind = np.full(len(dateIn),-1) # use the last hard-coded value (same result as last available FORTRAN version)
        if mode_dT==&#39;historical&#39;: # use the historical hard-coded values to reproduce results from older FORTRAN versions
            ind[dateIn&lt;dt.datetime(2013,10, 1)]=2
            ind[dateIn&lt;dt.datetime(2001,11,22)]=1
            ind[dateIn&lt;dt.datetime(1994, 8,23)]=0
        dT_TTyear = list(map(dT_TTyear.__getitem__, ind))
        dT_TTval  = list(map(dT_TTval.__getitem__,  ind))
        dT_TTinc  = list(map(dT_TTinc.__getitem__,  ind))

        # approximation of dT in requested year (dT = TT-UT1)
        dT_TT = (dT_TTval+dT_TTinc*(np.array(dateIn.year)-dT_TTyear))/86400 # approximation of dT_TT in [year]

    elif mode_dT==&#39;exact&#39;:
        # hard-coded list with leap seconds
        NTP = {&#39;1972-01-01&#39;:10,
               &#39;1972-07-01&#39;:11,
               &#39;1973-01-01&#39;:12,
               &#39;1974-01-01&#39;:13,
               &#39;1975-01-01&#39;:14,
               &#39;1976-01-01&#39;:15,
               &#39;1977-01-01&#39;:16,
               &#39;1978-01-01&#39;:17,
               &#39;1979-01-01&#39;:18,
               &#39;1980-01-01&#39;:19,
               &#39;1981-07-01&#39;:20,
               &#39;1982-07-01&#39;:21,
               &#39;1983-07-01&#39;:22,
               &#39;1985-07-01&#39;:23,
               &#39;1988-01-01&#39;:24,
               &#39;1990-01-01&#39;:25,
               &#39;1991-01-01&#39;:26,
               &#39;1992-07-01&#39;:27,
               &#39;1993-07-01&#39;:28,
               &#39;1994-07-01&#39;:29,
               &#39;1996-01-01&#39;:30,
               &#39;1997-07-01&#39;:31,
               &#39;1999-01-01&#39;:32,
               &#39;2006-01-01&#39;:33,
               &#39;2009-01-01&#39;:34,
               &#39;2012-07-01&#39;:35,
               &#39;2015-07-01&#39;:36,
               &#39;2017-01-01&#39;:37,
               }
        NTP_valid = dt.datetime(2021, 12, 28) #display warning after this date

        NTP_date = [dt.datetime.strptime(x,&#39;%Y-%m-%d&#39;) for x in [*NTP]]
        leap_sec = list(NTP.values())
        ind = np.full(len(dateIn),-1)
        for iD in range(len(NTP_date)-2,-1,-1):
            ind[dateIn&lt;NTP_date[iD]]=iD
        dT_TT  = (np.array(32.184) + list(map(leap_sec.__getitem__,  ind)) )/86400

        if (dateIn&gt;NTP_valid).any():
            print(&#39;WARNING: hard-coded leap-second dataset is officially valid for dates up to %s for mode &#34;exact&#34;. After this date, Astrog extrapolates based on last available leap-second values. To update the dataset, check: https://www.ietf.org/timezones/data/leap-seconds.list&#39;%(NTP_valid.date()))
            leap_sec_5yBefore = leap_sec[np.where(np.array(NTP_date)&lt;NTP_valid-dt.timedelta(days=370*5))[0][-1]]
            dT_TTyear = NTP_valid.year
            dT_TTval  = leap_sec[-1]
            dT_TTinc  = (dT_TTval-leap_sec_5yBefore)/5
            # approximation of dT in requested year (dT = TT-UT1)
            dT_TT_extrapolated = (np.array(32.184) + dT_TTval+dT_TTinc*(np.array(dateIn.year)-dT_TTyear))/86400
            dT_TT[np.array(dateIn.year)-dT_TTyear&gt;0] = dT_TT_extrapolated[np.array(dateIn.year)-dT_TTyear&gt;0]

    else:
        raise Exception(&#39;mode=%s not recognized&#39;%(mode_dT))

    return dT_TT</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.convert_str2datetime"><code class="name flex">
<span>def <span class="ident">convert_str2datetime</span></span>(<span>datetime_in_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Tries to convert datetime_in_list (list of str or datetime.datetime) to list of datetime.datetime</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datetime_in_list</code></strong> :&ensp;<code>list</code> of <code>str/dt.datetime/pd.Timestamp</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>datetime_out_list</code></strong> :&ensp;<code>list</code> of <code>pd.Timestamp</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_str2datetime(datetime_in_list):
    &#34;&#34;&#34;
    Tries to convert datetime_in_list (list of str or datetime.datetime) to list of datetime.datetime

    Parameters
    ----------
    datetime_in_list : list of str/dt.datetime/pd.Timestamp
        DESCRIPTION.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    datetime_out_list : list of pd.Timestamp
        DESCRIPTION.

    &#34;&#34;&#34;
    import datetime as dt
    import pandas as pd

    datetime_out_list = datetime_in_list
    for iDT, datetime_in in enumerate(datetime_in_list):
        if isinstance(datetime_in,pd._libs.tslibs.timestamps.Timestamp):
            datetime_out = datetime_in
        elif isinstance(datetime_in, dt.datetime):
            datetime_out = pd.Timestamp(datetime_in)
            if hasattr(datetime_out,&#39;tz&#39;):
                if datetime_out.tz != None:
                    raise Exception(&#39;tFirst and tLast should be timezone naive dt.datetime or &#34;yyyymmdd&#34; str&#39;)
        else:
            try:
                datetime_out = dt.datetime.strptime(datetime_in,&#39;%Y%m%d&#39;)
            except:
                raise Exception(&#39;date_input should be timezone naive dt.datetime or &#34;yyyymmdd&#34; str&#39;)
                
    return datetime_out_list</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.convert2perday"><code class="name flex">
<span>def <span class="ident">convert2perday</span></span>(<span>dataframeIn, timeformat='%H:%M %Z')</span>
</code></dt>
<dd>
<div class="desc"><p>converts normal astrog pd.DataFrame to one with the same information restructured per day</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataframeIn</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>with columns 'datetime' and 'type_str'.</dd>
<dt><strong><code>timeformat</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>format of the timestrings in dataframeOut. The default is '%H:%M %Z'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dataframeOut</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>The 'datetime' column contains dates, with columns containing all unique 'type_str' values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert2perday(dataframeIn, timeformat=&#39;%H:%M %Z&#39;):
    &#34;&#34;&#34;
    converts normal astrog pd.DataFrame to one with the same information restructured per day

    Parameters
    ----------
    dataframeIn : pd.DataFrame
        with columns &#39;datetime&#39; and &#39;type_str&#39;.
    timeformat : str, optional
        format of the timestrings in dataframeOut. The default is &#39;%H:%M %Z&#39;.

    Returns
    -------
    dataframeOut : pd.DataFrame 
        The &#39;datetime&#39; column contains dates, with columns containing all unique &#39;type_str&#39; values.

    &#34;&#34;&#34;
    
    dataframeOut = dataframeIn.copy()
    dataframeOut.index = dataframeOut[&#39;datetime&#39;].dt.date
    for type_sel in dataframeOut[&#39;type_str&#39;].unique():
        dataframeOut[type_sel] = dataframeOut[&#39;datetime&#39;][dataframeOut[&#39;type_str&#39;]==type_sel].dt.strftime(timeformat)
    dataframeOut.drop([&#39;type&#39;,&#39;type_str&#39;],axis=&#39;columns&#39;,inplace=True)
    dataframeOut = dataframeOut[~dataframeOut.index.duplicated(keep=&#39;first&#39;)]
    dataframeOut[&#39;datetime&#39;] = dataframeOut.index #overwrite datetime with dates
    
    return dataframeOut</code></pre>
</details>
</dd>
<dt id="hatyan.astrog.plot_astrog_diff"><code class="name flex">
<span>def <span class="ident">plot_astrog_diff</span></span>(<span>pd_python, pd_fortran, typeUnit='-', typeLab=None, typeBand=None, timeBand=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots results of FORTRAN and python verison of astrog for visual inspection.
Top plot shows values or type, middle plot shows time difference, bottom plot shows value/type difference.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pd_python</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>DataFrame from astrog (python) with times (UTC).</dd>
<dt><strong><code>pd_fortran</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>DataFrame from astrog (FORTRAN) with times (UTC).</dd>
<dt><strong><code>typeUnit</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Unit of provided values/types. The default is '-'.</dd>
<dt><strong><code>typeLab</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>Labels of provided types. The default is ['rise','set'].</dd>
<dt><strong><code>typeBand</code></strong> :&ensp;<code>list</code> of <code>floats</code>, optional</dt>
<dd>Expected bandwith of accuracy of values/types. The default is [-.5,.5].</dd>
<dt><strong><code>timeBand</code></strong> :&ensp;<code>list</code> of <code>floats</code>, optional</dt>
<dd>Expected bandwith of accuracy of times (seconds). The default is [0,60].</dd>
<dt><strong><code>timeLim</code></strong> :&ensp;<code>list</code> of <code>floats</code>, optional</dt>
<dd>Time limits of x-axis. The default is None (takes limits from pd_python).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>figure handle</code></dt>
<dd>Output figure.</dd>
<dt><strong><code>axs</code></strong> :&ensp;<code>axis handles</code></dt>
<dd>Axes in figure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_astrog_diff(pd_python, pd_fortran, typeUnit=&#39;-&#39;, typeLab=None, typeBand=None, timeBand=None):
    &#34;&#34;&#34;
    Plots results of FORTRAN and python verison of astrog for visual inspection.
    Top plot shows values or type, middle plot shows time difference, bottom plot shows value/type difference.

    Parameters
    ----------
    pd_python : pandas DataFrame
        DataFrame from astrog (python) with times (UTC).
    pd_fortran : pandas DataFrame
        DataFrame from astrog (FORTRAN) with times (UTC).
    typeUnit : string, optional
        Unit of provided values/types. The default is &#39;-&#39;.
    typeLab : TYPE, optional
        Labels of provided types. The default is [&#39;rise&#39;,&#39;set&#39;].
    typeBand : list of floats, optional
        Expected bandwith of accuracy of values/types. The default is [-.5,.5].
    timeBand : list of floats, optional
        Expected bandwith of accuracy of times (seconds). The default is [0,60].
    timeLim : list of floats, optional
        Time limits of x-axis. The default is None (takes limits from pd_python).

    Returns
    -------
    fig : figure handle
        Output figure.
    axs : axis handles
        Axes in figure.

    &#34;&#34;&#34;
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    
    if hasattr(pd_python[&#39;datetime&#39;].dtype,&#39;tz&#39;):
        pd_python = pd_python.copy() #do not overwrite original dataframe, so make a copy
        pd_python[&#39;datetime&#39;] = pd_python[&#39;datetime&#39;].dt.tz_localize(None) #Passing None will remove the time zone information preserving local time. https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_localize.html#pandas.Series.dt.tz_localize
    
    typeName = pd_python.columns[1]
    fig, (ax1,ax2,ax3) = plt.subplots(3,1,figsize=(15,9),sharex=True)
    ax1.set_title(&#39;%s&#39;%(typeName))
    ax1.plot(pd_python[&#39;datetime&#39;], pd_python[typeName], label=&#39;python&#39;)
    ax1.plot(pd_fortran[&#39;datetime&#39;],pd_fortran[typeName],label=&#39;FORTRAN&#39;,linestyle=&#39;dashed&#39;)
    if typeName == &#39;type&#39;:
        if typeLab is not None:
            ax1.set_ylim(1,len(typeLab))
            ax1.set_yticks(np.arange(1,len(typeLab)+1,step=1))
            ax1.set_yticklabels(typeLab)
    ax1.set_ylabel(&#39;%s [%s]&#39;%(typeName, typeUnit))
    ax1.legend(loc=1)

    ax2.plot(pd_python[&#39;datetime&#39;],(pd_python[&#39;datetime&#39;] - pd.to_datetime(pd_fortran[&#39;datetime&#39;])).dt.total_seconds())
    if timeBand is not None:
        ax2.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[timeBand[0],timeBand[0]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
        ax2.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[timeBand[1],timeBand[1]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
    ax2.set_ylabel(&#39;python - FORTRAN [seconds]&#39;)
    ax2.set_title(&#39;time difference [seconds]&#39;)

    ax3.plot(pd_python[&#39;datetime&#39;],pd_python[typeName] - pd_fortran[typeName])
    if typeBand is not None:
        ax3.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[typeBand[0],typeBand[0]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
        ax3.plot(pd_python[&#39;datetime&#39;].iloc[[0,-1]],[typeBand[1],typeBand[1]],color=&#39;k&#39;,linestyle=&#39;dashed&#39;)
    ax3.set_ylabel(&#39;python - FORTRAN [%s]&#39;%(typeUnit))
    ax3.set_title(&#39;%s difference [%s]&#39;%(typeName, typeUnit))

    ax1.set_xlim(pd_python[&#39;datetime&#39;].iloc[[0,-1]])
    fig.tight_layout()

    axs = (ax1,ax2,ax3)
    return fig, axs</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hatyan" href="index.html">hatyan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hatyan.astrog.astrog_culminations" href="#hatyan.astrog.astrog_culminations">astrog_culminations</a></code></li>
<li><code><a title="hatyan.astrog.astrog_phases" href="#hatyan.astrog.astrog_phases">astrog_phases</a></code></li>
<li><code><a title="hatyan.astrog.astrog_sunriseset" href="#hatyan.astrog.astrog_sunriseset">astrog_sunriseset</a></code></li>
<li><code><a title="hatyan.astrog.astrog_moonriseset" href="#hatyan.astrog.astrog_moonriseset">astrog_moonriseset</a></code></li>
<li><code><a title="hatyan.astrog.astrog_anomalies" href="#hatyan.astrog.astrog_anomalies">astrog_anomalies</a></code></li>
<li><code><a title="hatyan.astrog.astrog_seasons" href="#hatyan.astrog.astrog_seasons">astrog_seasons</a></code></li>
<li><code><a title="hatyan.astrog.astrab" href="#hatyan.astrog.astrab">astrab</a></code></li>
<li><code><a title="hatyan.astrog.astrac" href="#hatyan.astrog.astrac">astrac</a></code></li>
<li><code><a title="hatyan.astrog.dT" href="#hatyan.astrog.dT">dT</a></code></li>
<li><code><a title="hatyan.astrog.convert_str2datetime" href="#hatyan.astrog.convert_str2datetime">convert_str2datetime</a></code></li>
<li><code><a title="hatyan.astrog.convert2perday" href="#hatyan.astrog.convert2perday">convert2perday</a></code></li>
<li><code><a title="hatyan.astrog.plot_astrog_diff" href="#hatyan.astrog.plot_astrog_diff">plot_astrog_diff</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>